## 注意事项
- 数组操作，尤其注意越界的问题。

### 字符串匹配 KMP算法
其中next数组的求法是利用i,j两个下标模拟两个字符串，分别表示最长前缀和最长后缀，并且通过之前求的next数值进一步省略回溯。

另外还可以利用ac自动机，其有单模和多模之分。

### 括号匹配
Leetcode32题，要求返回最长的合法括号长度。利用动态规划
```
int longestValidParentheses(string s) {
    int len = s.length();
int* dp = new int[len];
int res = 0;
memset(dp, 0, len*sizeof(int));
for(int i = 1;i < len;++i){
  if(s[i] == ')' && s[i - 1] == '('){
    dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;
  }
  else if(s[i] == ')' && s[i-1]==')'){
    if(i - dp[i - 1] > 0 && s[i - dp[i - 1] - 1] == '('){
      dp[i] = dp[i-1] + ((i - dp[i - 1]) >= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2;
    }
  }
  res = max(res, dp[i]);
    }
    return res;
}
```
动态规划方程如下：

$s[i] = )且 s[i-1] =(时：dp[i] = dp[i-2] + 2$

$s[i] = ) 且 s[i - 1] = )时：如果s[i - dp[i - 1] - 1] = ( 则 dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2$

### 最短路径和
Leetcode64题，题目是典型的动态规划求解，可以进行空间优化，从$N^{2}$ 优化到$N$
```
//无优化版本 时间:12ms 内存消耗10.7M
int minPathSum(vector<vector<int>>& grid) {
int len1 = grid.size();
int len2 = grid[0].size();
    int** dp = new int*[len1];
for(int i = 0;i < len1;++i){
  dp[i] = new int[len2];
  memset(dp[i], 0, len2*sizeof(int));
}
dp[0][0] = grid[0][0];
for(int i = 1;i < len1;++i){
  dp[i][0] = grid[i][0] + dp[i - 1][0];
}
for(int i = 1;i < len2;++i){
  dp[0][i] = grid[0][i] + dp[0][i - 1];
}
for(int i = 1;i < len1;++i){
  for(int j = 1;j < len2;++j){
    dp[i][j] = min(dp[i-1][j],dp[i][j-1]);
  }
}
return dp[len1-1][len2-1];
}
```

```
\\一维空间版本：时间8ms,内存消耗10.4M
int minPathSum(vector<vector<int>>& grid) {
int len1 = grid.size();
int len2 = grid[0].size();
    int* dp = new int[len2];
dp[0] = grid[0][0];
for(int i = 1;i < len2;++i){
  dp[i] = grid[0][i] + dp[i - 1];
}
for(int i = 1;i < len1;++i){
  dp[0] = grid[i][0] + dp[0];
  for(int j=1;j<len2;++j){
    dp[j] = grid[i][j] + min(dp[j-1],dp[j]);
  }
}
return dp[len2-1];
}
```
