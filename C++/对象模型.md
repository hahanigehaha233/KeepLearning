## 虚函数表

虚函数表中的offset_to_top字段表示从对象初始地址到该派生类起始地址的长度。

>The offset to top holds the displacement to the top of the object from the location within the object of the virtual table pointer that addresses this virtual table, as a ptrdiff_t. It is always present. The offset provides a way to find the top of the object from any base subobject with a virtual table pointer. This is necessary for dynamic_cast in particular.
(In a complete object virtual table, and therefore in all of its primary base virtual tables, the value of this offset will be zero. [...])


`typeinfo`指针是记录对象指针的真实类型，用于运行时多态
>The typeinfo pointer points to the typeinfo object used for RTTI. It is always present. All entries in each of the virtual tables for a given class must point to the same typeinfo object. A correct implementation of typeinfo equality is to check pointer equality, except for pointers (directly or indirectly) to incomplete types. The typeinfo pointer is a valid pointer for polymorphic classes, i.e. those with virtual functions, and is zero for non-polymorphic classes.

## 构造函数
一个类中没有编写构造函数，可能不会生成默认的构造函数，只有在四种情况下会生成默认构造函数。
1. 该类中有“带有默认构造函数”的类成员对象。
2. 该类中有“带有默认构造函数”的基类。
3. 该类或者其base class中有虚函数。
4. 带有虚基类的类。

**编译器的默认构造函数不会对整数、整数指针、整数数组等进行初始化，这是程序员的责任。**

## 拷贝构造函数
当Class中有位逐次拷贝出现的时候，拷贝构造函数便不会产生，这是因为此类可以通过
每个位拷贝从而达到构造的效果。不会Bitwise Copy Semantics的情况有:
- class中有member object而后者的class声明有一个拷贝构造函数时。就算是被合成的也可以。**默认生成的拷贝构造函数对整数、整数指针和整数数组等都会进行赋值。**
- 继承的base class中有一个拷贝构造函数时。
- class中声明了一个或多个虚函数时。
- class中有继承虚基类时。

虚函数表会在构造函数的时候显示设定，并不是一味的拷贝。


### 初始化列表
当出现以下情况，一定要使用初始化列表：
- 当初始化一个引用成员时；
- 当初始化一个常量成员时；
- 当调用一个base class的构造函数，而它拥有一组参数时；
- 当调用一个mumber class的构造函数，而它拥有一组参数时；

如果针对拥有无参构造函数的mumber class，没有使用初始化列表时，其实会创建一个临时对象，然后进行赋值、销毁操作。

初始化列表的内部操作是：以适当的顺序在构造函数最前面安插初始化操作，**list中的对象顺序其实是由class中的members声明顺序决定的，跟初始化列表中的排列顺序无关**


## 数据语义
### .操作符存取和->操作符存取
```
origin.x = 0.0;
pt->x = 0.0;
```
这两个操作，在pt指向的对象是派生类，而pt是基类类型，其继承结构中有virtual继承，并且x是一个从virtual base class中继承来的member时，这两个操作有些不同，而对于普通的继承得来的成员、static member或者Derived member等，操作时间都是相同的。

《深入C++》P99


### 虚拟继承下的内存分布
**虚拟继承下，内存并不是按照基类到派生类（由低到高），而是按照派生类到基类（由低到高），且虚函数指针在最前面**


### 菱形虚拟继承的数据顺序
先是D的虚函数指针，再是B的数据，再是B的虚函数指针，再是C的数据，（如果BC相同，则优化掉一个虚函数指针），再是D的数据，再是A的数据和虚函数指针

## 函数语义

C++中支持三种形式的函数调用`static`、`non-static`和`virtual`,每一种类型被调用的方式都不相同。

### `Nonstatic Member Functions`
非静态成员函数和一般的非成员函数拥有相同的执行效率，这是C++标准所规定的，在实际的实现过程中，成员函数实惠被内化为非成员函数的形式。转换步骤如下（编译期执行的）：
1. 改写函数原型以安插一个额外的参数到成员函数中，用以提供一个存取管道，这个额外参数便是`this`指针。
2. 对函数内的每一个"对`non-static data member`的存取操作"改为经由`this`指针来存取。
3. 将`member function`重新写成一个外部函数，并且将函数名经过“mangling”处理使得其成为独一无二的语汇。


### `Virtual Member Functions`
如果函数是一个虚拟成员函数，例如`normalize()`那么以下的调用
```
ptr->normalize();

将会被内部转化为：

(* ptr->vptr[1]) (ptr);

```
其中：
- vptr表示由编译期产生的指针，指向`virtual table`。它被安插在每一个“声明有（或继承自）一个或多个`virtual functions`”的class object中。其名字也会被“mangled”，因为在一个复杂的class派生体系中，可能存在多个`vptrs`。
- 1 是 `virtual table slot`的索引值，关联到`normalize()`函数。
- 第二个`ptr`表示`this`指针。

在虚函数中调用虚函数，会因为先前虚函数调用后的决议，减少后面虚拟机制的不必要操作。例如
```
register float mag = magnitude();
原本应该是转换为
register float mag = (* this->vptr[2])(this);
而简化之后就变成了
register float mag = Point3d::magnitude();
```

**重点：经过一个`class object`调用一个`virtual function`，这种操作应该总是会被编译器按照`non-static member function`一样操作**

### `Static Member Functions`
静态成员函数设计最初的目的是想拥用不适用class object的方法或者成员，也就是调用函数时没有`this`指针。
- 它不能直接存取其class中的`nonstatic members`
- 它不能够被声明为const、volatile或virtual
- 它不需要经由class object才被调用
- 如果取一个`static member function`的地址，获得的将是其在内存中的位置，也就是其地址。由于其没有this指针，所以其地址并不是一个“指向class member function的指针”，而是一个“nonmember函数指针”。
```
&Point3d::object_count();
会得到一个数值，类型是
unsigned int (*)();

而不是
unsigned int (Point3d::*)();

```

---

## 虚拟成员函数
每个类只有一张虚函数表，为了支持虚特征，每个`class object`都有一个指向该类的虚表的指针，程序在编译阶段便可以确定每个类中的虚函数表的构造，每个slot中的函数，但是只有在运行的时候，程序才能知道具体调用的虚函数输入哪个类。

### 多重继承
在多重继承下支持`virtual functions`，其复杂度围绕在第二个以及后面的base class身上，以及必须在执行期间调整`this`指针这一点。

- 会含有多个虚表指针，且派生类中的虚函数会和第一个继承的虚表放在一起。所以
  - 通过一个“指向第二个base class”的指针，调用derived class virtual function会有调整指针操作。
  - 通过一个“指向derived class”的指针，调用第二个base class中的一个继承而来的virtual function。这种情况指针必须再次调整。
  - 允许虚函数的返回值类型变化的情况下，例如虚函数做拷贝构造函数
```
Base2 *pb1 = new Derived;

Base2 *pb2 = pb1->clone();

当进行pb1->clone()时，pb1会被调整指向Derived对象的起始地
址，于是clone()的Derived版会被调用；它会回传一个指针，指向
一个新的Derived对象；该对象的地址在被指定给pb2之前，必须先经
过调整，以指向Base2 subobject。

```


### 函数指针
多重继承下的指向虚函数的函数指针情况较为复杂《深入理解C++对象模型》P174

---

## 模板
当编译器看到一个模板声明的时候，它并不会去处理（所以static修饰的变量在此时也不会初始化），而是等到相应对象声明的时候才会进行操作，模板类的真正对象布局才会被产生出来。

编译器在处理模板操作的时候只会进行简单的语法检查，而parsing操作会延迟知道真正有实例化操作（instantiation）发生时才会开始。

在处理函数名称决议时，如果该函数使用的是与模板类型相关联的参数类型，则由实例化时期指定，如果使用的不是模板相关类型，则由声明时期代码决定。

### 函数行为
模板类中的函数只会等到真正使用的时候才会被按照类型实例化出来。
