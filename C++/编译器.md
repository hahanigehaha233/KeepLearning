## g++ 编译选项

-I 指定目录搜索头文件。

-L 指定目录寻找库文件。

-l 库名。

-fno-builtin GCC编译器提供了很多内置函数，它会把一些常用的C库函数替换成编译器的内置函数，以达到优化的目的。

-e 表示程序的默认入口函数名称

## CMake
CMake工具是一个协助开发人员编写Makefile文件的工具，它可以大量减少开发人员编写Makefile文件的
时间，基本用法如下：
- `cmake_minimum_required`：最低的cmake版本要求。
- `project`：项目名称
- `aux_source_directory`：将制定目录下的源文件列表作为变量保存。
- `add_executable`：使用源文件生成可执行文件。
- `include_directories`：向工程添加多个制定头文件的搜索路径，空格分开。
- `add_subdirectory`：向工程中添加存放源文件的目录。
- `set`：设置变量。
- `add_library`:生成动态库或静态库。(第1个参数指定库的名字；第2个参数决定是动态还是静态，如果没有就默认静态；第3个参数指定生成库的源文件)
- `set_target_properties`:设置输出的名称，还有其它功能，如设置库的版本号等等
- `LIBRARY_OUTPUT_PATH`:库文件默认输出位置。
- `link_directories`：添加非标准库的搜索路径。
- `target_link_libraries`：把目标文件和库文件进行链接。
- `add_compile_options`：编译选项

一般的C++项目中文件目录结构分为`bin、build、include、src、lib`，`bin`存放的是最后生成的可执行文件，`build`中往往是生成的对象文件，`include`一般存放头文件，`src`中放入源文件。`lib`中一般是库文件。

[简明教程](https://blog.csdn.net/whahu1989/article/details/82078563)


## 编译和链接
一个.c程序从编写出到运行分为：`预编译、编译、汇编和链接`四个过程，其中：
- 预编译阶段是处理`#`开头的语句。
- 编译阶段是将源文件处理成汇编语言组成的文件。
- 汇编是将汇编代码转变成为机器可以执行的代码。
- 链接是把可执行文件中用到的其他代码连接起来达到可以执行的状态。
### 编译过程
1. 词法分析
2. 语法分析
3. 语义分析
4. 中间语言生成：源码级优化器会在源码级别进行优化。
5. 代码生成器和目标代码优化器，代码生成器将目标代码转换成目标机器代码，这个过程十分依赖于目标机器，因为不同的机器有着不同的字长、寄存器、整数据类类型和浮点数数据类型。之后根据目标代码优化器进行优化。
6. 目标代码要通过链接器将这些目标文件链接起来形成可执行文件


### 链接
链接的主要内容就是把各个模块之间互相引用的部分都处理好，使得各个模块之间能够正确的衔接。主要包括了地址和空间分配（Address and Storage Allocation）、符号决议（Symbol Resolution）和重定位（Relocation）。

## 目标文件
从结构上来讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有些符号或有些地址还没有被调整。其实它本身就是按照可执行文件格式存储的。动态、静态链接库都是按照可执行文件的格式存储的。

## 目标文件中的段
- `.text`:存放程序的代码
- `.data`:存放已经初始化的全局静态变量和局部静态变量
- `.bss`:未初始化的全局变量和局部静态变量，有些编译器会放有些不会，只留一个未定义的全局变量符号，等待最终链接时才在`.bss`分配空间。在程序执行前bss段会自动清0.

**static int x1 = 0 是放在bss段的，因为这样优化可以节省磁盘空间，等运行时在分配内存**

- `.rodata1`:存放的只读数据，比如字符串常量】全局const变量
- `.comment`:存放编译器版本信息
- `.debug`:调试信息
- `.dynamic`:动态链接信息
- `.hash`:符号哈希表
- `.line`:调试时会用到的行号表
- `.note`:额外的编译器信息
- `.strtab`:String Table字符串表，用于存储ELF文件中用到的各种字符串
- `.symtab`:Symbol Table符号表
- `.shstrtab`:Section String table 段名表
- `.plt`动态链接跳转表
- `.init`程序初始化与终结代码段

除了段默认存放的规则，GCC还提供了扩展机制，使得程序员可以指定变量所处的段。

### ELF文件头
（ELF Header）中包含了描述整个文件的基本属性，比如ELF文件版本、目标机器型号、程序入口地址等。紧接着是ELF文件各个段。

### 重定位表
链接器在处理目标文件时，需要对目标文件中的某些部位进行重定位，即代码段和数据段中那些对绝对地址引用的位置，这些重定位信息都被记录在这个表中，对于每一个需要重定位的代码段或数据段，都会有一个相应的重定位表。例如对`printf`函数的调用就需要重定位。

重定位表中都是需要修正的地址，进行符号解析和地址修正后，链接工作就完成了。具体参考110页。

链接成最终的可执行文件时，对虚拟地址进行修正。
- 符号解析：每个目标文件都会定义一些符号，也都会引用到一些其他目标文件的符号，当链接器需要对某个符号的引用进行重定位时，它就要确定这个符号的目标地址。这时候链接器就会去查找由所有输入目标文件的符号组成的全局符号表，找到相应的符号后进行重定位。
- 指令修正通常分为相对寻址修正和绝对寻址修正。

## 虚拟地址空间
每个程序被运行起来以后，它将拥有自己独立的虚拟地址空间（Virtual Address Space），这个虚拟地址空间由计算机的硬件平台决定，具体地说是由CPU的位数决定的，32位的硬件平台也就是我们常说的4GB虚拟空间大小；一般来说，C语言指针大小和位数与虚拟空间的位数相同，如32为平台下指针是32位即4个字节；64为平台下的指针为64位，即8字节。

真正留给进程可以使用的虚拟地址空间是不到4G的。

**虚拟地址空间并不是真正的空间，可以将它理解为一个页表，这个页表记录着真实的物理地址空间，并且在访问时通过页表进行访问，发生页错误时从磁盘中读取再重新装入**

在虚拟空间中建立好与可执行文件的映射关系之后，将CPU指令寄存器设置为可执行文件入口，便可以进行程序处理。
[虚拟地址和实际地址](https://blog.csdn.net/lvyibin890/article/details/82217193)

### 可执行文件的装载方式
现代操作系统通常采用页装载的方式，将内存和所有磁盘中的指令和数据按照“页”为单位划分，后面的装载就是以页为单位进行装载。这里会牵扯到内存换页算法如FIFO先进先出算法、LUR最少使用算法等。
