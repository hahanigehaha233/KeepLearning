## g++ 编译选项

-I 指定目录搜索头文件。

-L 指定目录寻找库文件。

-l 库名。

-fno-builtin GCC编译器提供了很多内置函数，它会把一些常用的C库函数替换成编译器的内置函数，以达到优化的目的。

-e 表示程序的默认入口函数名称

## CMake
CMake工具是一个协助开发人员编写Makefile文件的工具，它可以大量减少开发人员编写Makefile文件的
时间，基本用法如下：
- `cmake_minimum_required`：最低的cmake版本要求。
- `project`：项目名称
- `aux_source_directory`：将制定目录下的源文件列表作为变量保存。
- `add_executable`：使用源文件生成可执行文件。
- `include_directories`：向工程添加多个制定头文件的搜索路径，空格分开。
- `add_subdirectory`：向工程中添加存放源文件的目录。
- `set`：设置变量。
- `add_library`:生成动态库或静态库。(第1个参数指定库的名字；第2个参数决定是动态还是静态，如果没有就默认静态；第3个参数指定生成库的源文件)
- `set_target_properties`:设置输出的名称，还有其它功能，如设置库的版本号等等
- `LIBRARY_OUTPUT_PATH`:库文件默认输出位置。
- `link_directories`：添加非标准库的搜索路径。
- `target_link_libraries`：把目标文件和库文件进行链接。
- `add_compile_options`：编译选项

一般的C++项目中文件目录结构分为`bin、build、include、src、lib`，`bin`存放的是最后生成的可执行文件，`build`中往往是生成的对象文件，`include`一般存放头文件，`src`中放入源文件。`lib`中一般是库文件。

[简明教程](https://blog.csdn.net/whahu1989/article/details/82078563)


## 编译和链接
一个.c程序从编写出到运行分为：`预编译、编译、汇编和链接`四个过程，其中：
- 预编译阶段是处理`#`开头的语句。
- 编译阶段是将源文件处理成汇编语言组成的文件。
- 汇编是将汇编代码转变成为机器可以执行的代码。
- 链接是把可执行文件中用到的其他代码连接起来达到可以执行的状态。
### 编译过程
1. 词法分析
2. 语法分析
3. 语义分析
4. 中间语言生成：源码级优化器会在源码级别进行优化。
5. 代码生成器和目标代码优化器，代码生成器将目标代码转换成目标机器代码，这个过程十分依赖于目标机器，因为不同的机器有着不同的字长、寄存器、整数据类类型和浮点数数据类型。之后根据目标代码优化器进行优化。
6. 目标代码要通过链接器将这些目标文件链接起来形成可执行文件


### 链接
链接的主要内容就是把各个模块之间互相引用的部分都处理好，使得各个模块之间能够正确的衔接。主要包括了地址和空间分配（Address and Storage Allocation）、符号决议（Symbol Resolution）和重定位（Relocation）。

## 目标文件
从结构上来讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有些符号或有些地址还没有被调整。其实它本身就是按照可执行文件格式存储的。动态、静态链接库都是按照可执行文件的格式存储的。

## 目标文件中的段
- `.text`:存放程序的代码
- `.data`:存放已经初始化的全局静态变量和局部静态变量
- `.bss`:未初始化的全局变量和局部静态变量，有些编译器会放有些不会，只留一个未定义的全局变量符号，等待最终链接时才在`.bss`分配空间。在程序执行前bss段会自动清0.

**static int x1 = 0 是放在bss段的，因为这样优化可以节省磁盘空间，等运行时在分配内存**

- `.rodata1`:存放的只读数据，比如字符串常量】全局const变量
- `.comment`:存放编译器版本信息
- `.debug`:调试信息
- `.dynamic`:动态链接信息
- `.hash`:符号哈希表
- `.line`:调试时会用到的行号表
- `.note`:额外的编译器信息
- `.strtab`:String Table字符串表，用于存储ELF文件中用到的各种字符串
- `.symtab`:Symbol Table符号表
- `.shstrtab`:Section String table 段名表
- `.plt`动态链接跳转表
- `.init`程序初始化与终结代码段

除了段默认存放的规则，GCC还提供了扩展机制，使得程序员可以指定变量所处的段。

### ELF文件头
（ELF Header）中包含了描述整个文件的基本属性，比如ELF文件版本、目标机器型号、程序入口地址等。紧接着是ELF文件各个段。

### 重定位表
链接器在处理目标文件时，需要对目标文件中的某些部位进行重定位，即代码段和数据段中那些对绝对地址引用的位置，这些重定位信息都被记录在这个表中，对于每一个需要重定位的代码段或数据段，都会有一个相应的重定位表。例如对`printf`函数的调用就需要重定位。

重定位表中都是需要修正的地址，进行符号解析和地址修正后，链接工作就完成了。具体参考110页。

链接成最终的可执行文件时，对虚拟地址进行修正。
- 符号解析：每个目标文件都会定义一些符号，也都会引用到一些其他目标文件的符号，当链接器需要对某个符号的引用进行重定位时，它就要确定这个符号的目标地址。这时候链接器就会去查找由所有输入目标文件的符号组成的全局符号表，找到相应的符号后进行重定位。
- 指令修正通常分为相对寻址修正和绝对寻址修正。
8
## 虚拟地址空间
每个程序被运行起来以后，它将拥有自己独立的虚拟地址空间（Virtual Address Space），这个虚拟地址空间由计算机的硬件平台决定，具体地说是由CPU的位数决定的，32位的硬件平台也就是我们常说的4GB虚拟空间大小；一般来说，C语言指针大小和位数与虚拟空间的位数相同，如32为平台下指针是32位即4个字节；64为平台下的指针为64位，即8字节。

真正留给进程可以使用的虚拟地址空间是不到4G的。

**虚拟地址空间并不是真正的空间，可以将它理解为一个页表，这个页表记录着真实的物理地址空间，并且在访问时通过页表进行访问，发生页错误时从磁盘中读取再重新装入**

在虚拟空间中建立好与可执行文件的映射关系之后，将CPU指令寄存器设置为可执行文件入口，便可以进行程序处理。
[虚拟地址和实际地址](https://blog.csdn.net/lvyibin890/article/details/82217193)

### 可执行文件的装载方式
现代操作系统通常采用页装载的方式，将内存和所有磁盘中的指令和数据按照“页”为单位划分，后面的装载就是以页为单位进行装载。这里会牵扯到内存换页算法如FIFO先进先出算法、LUR最少使用算法等。

而在具体装载时，并不是每个不同的段会不同的装载，为了避免页空间的浪费，会按照每个段的权限，引入了“Segment”的概念，一个“Segment”包含一个或者多个属性类似的“Section”，这样在装载的时候就可以将它们看做是一个整体一起映射，也就是说映射以后在进程虚拟空间中只有一个相对应的VMA，而不是两个，这样做的好处是可以很明显地减少页面内部碎片，从而节省了内存空间。

可以使用`readelf -S xxx.elf`查看程序的段信息，`readelf -l xxx.elf`来查看程序的"Segment"信息，例如
```

Elf file type is EXEC (Executable file)
Entry point 0x400a30
There are 6 program headers, starting at offset 64

Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000
                 0x00000000000b5796 0x00000000000b5796  R E    0x200000
  LOAD           0x00000000000b6120 0x00000000006b6120 0x00000000006b6120
                 0x00000000000051b8 0x00000000000068e0  RW     0x200000
  NOTE           0x0000000000000190 0x0000000000400190 0x0000000000400190
                 0x0000000000000044 0x0000000000000044  R      0x4
  TLS            0x00000000000b6120 0x00000000006b6120 0x00000000006b6120
                 0x0000000000000020 0x0000000000000060  R      0x8
  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000000 0x0000000000000000  RW     0x10
  GNU_RELRO      0x00000000000b6120 0x00000000006b6120 0x00000000006b6120
                 0x0000000000002ee0 0x0000000000002ee0  R      0x1

 Section to Segment mapping:
  Segment Sections...
   00     .note.ABI-tag .note.gnu.build-id .rela.plt .init .plt .text __libc_freeres_fn __libc_thread_freeres_fn .fini .rodata .stapsdt.base .eh_frame .gcc_except_table
   01     .tdata .init_array .fini_array .data.rel.ro .got .got.plt .data __libc_subfreeres __libc_IO_vtables __libc_atexit __libc_thread_subfreeres .bss __libc_freeres_ptrs
   02     .note.ABI-tag .note.gnu.build-id
   03     .tdata .tbss
   04     
   05     .tdata .init_array .fini_array .data.rel.ro .got

```
只有`Type`为LOAD的Segment才会被加载，其他的只是在装载中起到辅助作用。


**其实堆和栈在进程中也是通过VMA的形式表现出来的，一个进程基本上可以分为如下几种VMA区域**
- 代码VMA，权限只读、可执行；有映象文件（elf）
- 数据VMA，权限可读写、可执行；有映象文件（elf）
- 堆VMA，权限可读写、可执行；无映象文件，匿名，可向上扩展。
- 栈VMA，权限可读写、不可执行；无映象文件，匿名，可向下扩展。

## 动态链接
动态链接最大的不同就是程序是在装载时链接的，因此需要额外的方法去完成这项功能：
- 需要存放外部函数的数据段
- 获取数据段存放函数地址（GOT全局偏移表）的一小段额外代码（PLT程序链接表）

动态链接有两种链接方式：装载时重定位和PIC，装载时重定位失去了节省内存的有点，但是要比使用PIC的速度块，因为它省去了PIC中每次访问全局数据和函数时需要做一次计算当前地址以及间接地址寻址的过程。

### 地址无关代码（PIC Position-independent Code)
装载时重定位是解决动态模块中有绝对地址引用的方法之一，但是它有一个很大的缺点是指令无法在多个进程之间共享，这样就失去了动态链接节省内存的优势（装载时重定位会改变地址相关代码的执行，这样便不能在进程间共享。而且在载入时重定位也会影响时间。

因此发明了地址无关代码技术，在地址无关技术设计的时候就需要考虑代码中会对地址进行引用的情况，共享对象中地址引用可以分为以下几种情况：模块内函数调用、跳转等、模块内数据的访问，如模块内定义的静态变量，全局变量等、模块外部函数的调用、跳转等和模块外部的数据访问。
- 模块中访问内部函数：由于此时调用者和被调用者处于同一模块，所以位置固定，使用相对地址就可以了。
- 模块内部的数据调用：同上
- 模块外部的函数调用：此时需要将与地址相关的部分放入数据段，ELF中建立了一个指向这些函数的指针数组（GOT），当代码需要引用这些外部变量和函数的时候，可以通过相对应的项间接引用，动态链接器在装载模块的时候会查找每个函数所在地址，并填充GOT中的各个表项，以保证每个指针均指向正确的地址。同时由于GOT本身是放在数据段的，因此它可以在模块装载的时候被修改，并且每个进程都可有自己的副本。
- 模块外的数据调研：同上

在实际情况中还会加入PLT来进一步节省时间。
