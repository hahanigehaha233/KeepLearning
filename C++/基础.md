## 访问控制
- `Private`：私有级别，只允许
  1. 该类中的函数访问
  2. 该类的友元中的函数访问
- `Protected`:保护级别，只允许
  1. 该类中的函数访问
  2. 子类中的函数访问
  3. 友元中的函数访问
- `Public`：公有级别，允许
  1. 该类中的函数访问
  2. 子类中的函数访问
  3. 友元中的函数访问
  4. 类的对象访问

  注意：友元包括三种：设为友元的普通非成员函数；设为友元的其他类的成员函数；设为友元类的所有成员函数。

类继承后方法属性的变化：
- 使用`Private`继承：父类的`Public`和`Protected`在子类中变为`Private`。
- 使用`Protected`继承：父类的`Public`和`Protected`在子类中变为`Protected`。
- 使用`Public`继承：父类中的`Public`和`Protected`在子类中不改变。
- 切记将成员变量声明为`Private`。这可赋予客户访问数据的一致性、可细微划分访问控制、允许约束，并提供弹性。
- `protected`和`public`在某种意义上是一样的。

**虚继承：虚继承是为解决多重继承潜在问题而诞生的，其虚继承类中有虚基表，作用和虚函数表类似，子类中只会存在一份基类的拷贝**

## 运算符重载
自增运算符的重载规则
```
ite++(0);
ListIter operator++(int){
    ListIter tmp = this;
    ++*(this);
    return tmp;
}

++ite;
ListIter& operator(){
    ite->next();
    return *this;
}

```

### 类型转换
C++中的显式类型转换，包含四种：
- static_cast:主要用于内置类型之间的互相交换。也可以转换自定义类型。如果涉及到类，static_cast只能在有相互联系（继承）的类型间进行转换，且不一定包含虚函数。

- const_cast:常量对象转换为非常量对象，常量引用转为非常量引用. 顶层const和底层const都会消失
为什么会有const_cast改变底层的const:
应用场景一般是接口参数类型不同，但是明确知道不会改变的时
候。也是与老版本的C库兼容
[const_cast](https://www.zhihu.com/question/19772701/answer/20426924)

- dynamic_cast:类中需要有虚函数才能进行转换。
- reinterpret_cast

有着与C风格的强制转换同样的能力。
它可以转化任何内置的数据类型为其他任何的数据类型，也可以转化任何指针类型为其他的类型。
它甚至可以转化内置的数据类型为指针，无须考虑类型安全或者常量的情形。不到万不得已绝对不用。



---

#### malloc
malloc只是分配了虚拟地址空间，小于128KB的在堆上，大于128KB的在映射区中，它有一个将可用的内存块连接为一个长长的列表的所谓空闲链表。调用malloc函数时，它沿连接表寻找一个大到足以满足 用户请求所需要的内存块。然后，将该内存块一分为二（一块的大小与用户请求的大小相等，另一块的大小就是剩下的字节）。接下来，将分配给用户的那块内存传 给用户，并将剩下的那块（如果有的话）返回到连接表上。调用free函数时，它将用户释放的内存块连接到空闲链上。到最后，空闲链会被切成很多的小内存片 段，如果这时用户申请一个大的内存片段，那么空闲链上可能没有可以满足用户要求的片段了。于是，malloc函数请求延时，并开始在空闲链上翻箱倒柜地检 查各内存片段，对它们进行整理，将相邻的小空闲块合并成较大的内存块。 

**也就是说free一个小于128k的内存并不是会马上将指针移动到其下面，而是要看其上还有没有未free的地址，这样是会形成一些小的碎片的。**

malloc大于128k的内存，使用mmap分配内存，在堆和栈之间找一块空闲内存分配(对应独立内存，而且初始化为0)

其实，进程向 OS 申请和释放地址空间的接口 sbrk/mmap/munmap 都是系统调用，频繁调用系统调用都比较消耗系统资源的。并且， mmap 申请的内存被 munmap 后，重新申请会产生更多的缺页中断。例如使用 mmap 分配 1M 空间，第一次调用产生了大量缺页中断 (1M/4K 次 ) ，当munmap 后再次分配 1M 空间，会再次产生大量缺页中断。缺页中断是内核行为，会导致内核态CPU消耗较大。另外，如果使用 mmap 分配小内存，会导致地址空间的分片更多，内核的管理负担更大。

同时堆是一个连续空间，并且堆内碎片由于没有归还 OS ，如果可重用碎片，再次访问该内存很可能不需产生任何系统调用和缺页中断，这将大大降低 CPU 的消耗。 因此， glibc 的 malloc 实现中，充分考虑了 sbrk 和 mmap 行为上的差异及优缺点，默认分配大块内存 (128k) 才使用 mmap 获得地址空间，也可通过 mallopt(M_MMAP_THRESHOLD, <SIZE>) 来修改这个临界值。

#### 伙伴系统
用于管理物理页，主要目的在于维护可用的连续物理空间，避免外部碎片。所有关于内存分配的操作都会与其打交道，buddy是物理内存的管理的门户。Linux采用著名的。它把所有的空闲页放到11个链表中，每个链表分别管理大小为1，2，4，8，16，32，64，128，256，512，1024个页的内存块。当系统需要分配内存时，就可以从buddy系统中获取。例如，要申请一块包含4个页的连续内存，就直接从buddy系统中管理4个页连续内存的链表中获取。当系统释放内存时，则将释放的内存放回buddy系统对应的链表中，如果释放内存后发现有两块相邻的内存又可以合并为一个更高阶的内存块，例如释放4个页，而恰好相邻的内存也为4个页的空闲内存，则合并这两块内存并放到buddy系统管理8个连续页的链表中。同样的，如果系统需要申请3个页的连续内存，则只能在4个页的链表中获取，剩下的一个页被放到buddy系统中管理1个页的链表中。

slob：针对一些经常分配并释放的对象，如进程描述符等，这些对象的大小一般比较小，如果用buddy system来分配会造成大量的内存碎片，而且处理速度也太慢；slab分配器是基于对象进行管理的，相同类型的对象归为一类，每当要申请这样一个对象，slab分配器就从一个slab列表中分配一个这样大小的单元出去，而当要释放时，将其重新保存在该列表中，而不是直接返回给伙伴系统。slab分配对象时，会使用最近释放的对象内存块，因此其驻留在CPU高速缓存的概率较高。

在内核中想要分配一段连续的内存，首先向slab系统申请，如果不满足（超过两个页面，也就是8K），直接向buddy系统申请。如果还不满足（超过4M，也就是1024个页面），将无法获取到连续的物理地址。可以通过vmalloc获取虚拟地址空间连续，但物理地址不连续的更大的内存空间。

---

## `const`函数为什么不能是`staitc`
因为为了让函数不能改变对象值，传入了`const *this`指针，而`static`是没有this指针的。

## noexcept
作用在函数上，说明该函数不会发生异常，如果被修饰的函数发生了异常，编译器可以直接调用std::terminate()来终止程序的运行。这是因为异常机制会带来一些额外开销，比如函数抛出异常，会导致函数栈被依次地展开（unwind），并依帧调用在本帧中已构造的自动变量的析构函数等。

## Union
该结构会尽可能的少用内存，会使得里面的数据类型使用内存时重叠，该性质可以用来节约内存使用，例如STL中的空间配置器中二级配置器使用了，另外也可以判断处理器的端序问题。

先压栈的是低位的话则是小端，先是高位的话则是大端。读取一个数据的时候从低到高读取。
```
int checkCPU()
{
    {
        union w
        {
            int a;
            char b;
        } c;
        c.a = 1;
        return (c.b == 1);    //小端的话 c.b == 1  否则c.b == 0
    }
}

//Linux中的判断
static union
 {
        char c[4];
        unsigned long mylong;
} endian_test = {{ 'l', '?', '?', 'b' } };

#define ENDIANNESS ((char)endian_test.mylong)
```

## 内存对齐
1. 结构体变量的首地址能够被其最宽基本类型成员的大小所整除
2. 结构体每个成员相对结构体首地址的偏移量(offset)都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节(internal adding)
3. 结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节{trailing padding}

## 初始化
**初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来代替**

定义在函数体内部的内置类型变量将不被初始化。

## explicit关键字
针对类的构造函数是默认进行隐式转换的情况，可以使用`explicit`使其关闭默认转变。

[链接](https://blog.csdn.net/guoyunfei123/article/details/89003369)

## NULL和nullptr
在c语言中，NULL既可以是0也可以是(void*)0

但在c++中，这样会给函数重载带来困扰，造成歧义。

于是c++规定，在C++中，NULL只能代表整数0，而（void*)0则有nullptr代表，nullptr只代表空指针，不能表示整数0。其实就是把整数0和(void*)0，分开表示。

## 指针和引用的区别
引用需要初始化，且之后无法改变，**引用并非一个对象**

## Const
如果想在多个文件之间共享`const`对象，必须在变量的定义之前添加`extern`关键字。
在对`const`对象编译时，编译器会将所有用到该变量的地方都替换成对应的值。

const的引用，const引用只能引用常量对象。

引用的例外1：在初始化常量引用时允许用任意表达式作为初始值，只要该表达式能转换成引用的类型即可。这是因为编译器在处理常量引用类型的时将
```
const int &ri = dval;
变成了
const int temp = dval;
const int &ri = temp;
```
在这种情况下，常量引用实际上是绑定的一个临时量，所以可以使用任意可以转化为该类型的表达式，而非常量引用如果类型不同的话，参照上面的代码，实际上是引用的其他对象，这跟引用的初衷违背。

可以使用const修饰引用变量去引用一个非const对象，但是无法在在这个const引用上做更改。

const指针，常量指针需要初始化，并且不能修改其所指向的地址，但是其所指向的地址中的值如果不是常量的话则可以修改。
```
const int i = 1;
const int *curr = &i //curr是一个指针，指向一个int类型的常量
const int t =2;
curr = &t;//因为只是一个指针而已，所以可以改变指向的对象


const int i = 1;
const int *const curr = &i  //curr是一个常量指针，指向的是一个int类型的常量
const int j = 2;
curr = &j;//错误，因为是这个指针是被const修饰的，所以不能改变指向

```

底层const拷贝注意
```
const int v2 = 0; int v1 = v2;
int *p1 = &v1, &r1 = v1;
const int *p2 = &v2, *const p3 = &v2,&r2 = v2;

r1 = v2//值赋值，顶层可以

p1 = p2//p1是指向int的指针，而p2则是const int的指针，赋值给p1是会被改变的

p2=p1//顶层可以

p1 = p3;
p3 = p1
```

## constexpr
当认定一个变量是一个常量表达式，那就把它声明成为constexpr类型。并且constexpr把它所定义的对象置为了顶层const

## 指针、常量和类型别名
如果某个类型别名指代的是符合类型或常量，那么把它用到声明语句就会产生不同的效果，pstring是个类型别名,应该把它当成一个类型来看待,很显然pstring是一个指针类型,而const修饰的正是它,也就是说const修饰的是指针,所以这是个cstar是一个常量指针,这个常量指针指向一个char.

## auto
auto定义的变量，会自动忽略顶层const，在引用类型中，原来的初始化规则（顶层const）仍然适用。

## 数组和指针
```
int *p = arr;
int (*Parray)[10] = &arr;Parrray指向一个含有十个整数的数组
int (&arrRef)[10] = arr; arrRef引用一个含有十个整数的数组
(*Parray)[1]
*p或者p[1]都行
```

## 类型判断
**如果是数组的类型判断的话，从内向外读，如果是其他类型的话，从右向左读。**

## 左值和右值
当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。

左值可以被作为左值和右值，右值只能作为右值。

在左值被作为左值时，使用的是地址，被作为右值时，使用的是其地址上的值。

### 右值引用
[C++右值引用 - 小小将的文章 - 知乎](https://zhuanlan.zhihu.com/p/54050093)

**引用实际上就是一个封装好的指针，通常的左值引用其实是不需要自己解引用的指针，而右值引用则是将临时值放入匿名对象的一个指针，这个指针也不需要自己解引用**
[参考](https://blog.csdn.net/qq_33113661/article/details/89040579)

右值实际上就是只存在于寄存器中的值。

```
int a = 1
int &x = a ->  lea eax,[a]
               mov dword ptr[x], eax


int &&x = 1 ->  mov dword ptr[ebp-14h], 1
                lea eax [ebp-14h]
                mov dword ptr[ebp-10h], eax
```

右值引用即可以引用右值，其目的就是将该引用对象的资源进行利用，使得不用再构造额外的临时对象，对被引用对象所做的一切都会真实反映在该对象上。

```
int a = 1;
int&& b = a;//非法，右值引用的作用是延长用来初始化对象的生命周期，而a的生命周期是其作用域决定的。
int&& c = a+1;//合法，a+1的结果被c右值引用
```
### 移动构造函数
移动构造函数和移动赋值函数都是通过右值引用来完成的，如
```
DynamicArray(DynamicArray&& rhs) :
        m_size{ rhs.m_size }, m_array{rhs.m_array}
    {
        rhs.m_size = 0;
        rhs.m_array = nullptr;
        cout << "Move constructor: dynamic array is moved!\n";
    }
```
这样便节省了一次构造函数调用。析构函数依然会调用，因为临时对象rhs依然存在，不过只是一具空壳。

std::move()就是对右值引用移动的封装，在上面代码中我们需要手动设置nullptr，使用了std::move()就行了，并且有时候我们需要将一个左值转为右值，move就可以帮我们这样做。 const修饰的对象无法使用移动语义。

std::forward()完美转发，的作用是当传入的是一个右值引用的时候，在此对象作为参数传递的时候，传递的仍然是一个右值。

## 封装
封装有两个重要的优点：
- 确保用户代码不会无意间破坏封装对象的状态。
- 被封装的类的具体实现细节可以随时改变，而无需调整用户级别的代码。

如果数据定义为public的，则所用使用了原来数据成员的代码都有可能失效，这时必须重写。并且可以防止用户破坏。

## mutable
当一个函数不会改变对象的状态时，可以将这个函数声明为const，但如果需要在函数中修改一些和类状态无关的成员，就要用到mutalbe，尽管函数被const修饰，但是还是可以被修改。

在muduo中，对于一个get()函数，get本身是不会改变的，所以函数使用了const进行修饰，但是如果要对其加一个互斥锁的话，就不能const，所以办法是对互斥变量mutex声明为mutable。

## 初始化列表
如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始化列表为这些成员提供初始值。初始化列表的顺序是按照定义的顺序来进行初始化的。

## static关键字

### 修饰非类成员函数
对于两个不同文件，在不知情的情况下，如果存在两个同名函数的话，如果文件A引用了文件B，这样会造成编译不通过，这是因为普通函数具有全局可见性，所以在非类中，`static`修饰的函数通常作为隐藏作用使用。

### 修饰非类成员变量
C++对`static`关键字修饰的变量会在第一次经过这段代码的时候进行初始化，并且就算是局部变量，也只会在程序结束时才会释放内存，**但是需要注意的是，static的局部变量还是有一个可见范围，在作用域之外是无法访问的。**

**static变量也会默认初始化为0值**，static 变量只会初始化一次，在for循环中的初始化也只会执行一次，原理是利用变量地址后的一部分内存存储是否初始化过进行判断。

### 修饰对象中的成员时
这时表明这是类的静态成员，不是类的对象的成员，所以它没有this指针，这也导致了它只能访问类的静态数据和静态成员变量。

注意
- 不能将静态成员函数定义为虚函数
- 静态成员变量必须进行初始化

## virtual 关键字
被`virtual`修饰的函数称为虚函数， 普通函数不允许通过父类的指针访问子类的对象，这违背了C++的设计原则，而在现实场景中，要实现运行时多态，采用了虚函数来打破这个规则，**虚函数就是为了允许使用父类指针去调用子类的函数**，一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为“虚”函数。

**虚表是属于类的，而不是属于某一个具体的对象，一个类只需要一个虚表即可。同一个类的所有对象都使用同一个虚表**

为了制定对象的虚表，对象内部包含一个虚表的指针，来指向自己所使用的虚表，为了让每个包含虚表的类的对象都拥有一个虚表指针，编译器在类中添加了一个指针，`*__vptr`，用来指向虚表。这样，当类的对象在创建时便拥有了这个指针，且这个指针的值会自动被设置成指向类的虚表。

当一个指向子类的父类指针调用一个虚函数时，其流程如下：
```
B b;
A *a = &b;
a->foo();
```

1. 首先，根据虚表指针`p->__vptr`来访问对象b对应的虚表。虽然指针a是父类`A*`类型的，但是`*__vptr`是子类的一部分，所以可以通过`p->__vptr`访问到对象对应的虚表。
2. 然后，在虚表中查找所调用的函数对应的条目，由于虚表在编译阶段就可以构造出来，所以根据所调用的函数定位到虚表中对应条目。
3. 最后，根据虚表中的函数指针，调用函数。

**虚函数操作耗时主要体现在查表慢**

对于非多态类对象在虚拟继承中的存取，编译器可能存在不同的做法，见《深度探索C++模型》P129

[参考](https://blog.csdn.net/yc461515457/article/details/52658589)

## 模板
当编译器遇到一个模板定义时，它并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码。所以编译错误大多数是在实例化期间。

## pragma once和预处理的区别
ifndef方式依赖于宏名不能冲突。它不光可以保证同一个文件不会被包含多次，也能保证内容完全相同的两个文件不会被不小心同时包含。缺点是如果不同头文件中的宏名不小心”碰撞”，可能就会导致你看到头文件明明存在，编译器却硬说找不到声明的状况。

## 类中的`sizeof`
空类的大小为1字节，因为如果没有的话实例无法区分，所以产生了空基类最优化方法，将需要继承的非虚函数，typedef，static变量放入基类中达到继承并且减少内存消耗的效果。


## 堆栈区别
产生堆和栈两个内存区域的原因是因为：程序对处理的数据的要求不同，对于某一些作用时间短，不必共享的变量，需要频繁访问，程序可以放在一个区域，这个区域有专门的寄存器和指令进行操作，而且连续，不容易发生缺页中断；而对于一些其他的，体积大、生命周期长的，不需要频繁访问的，需要放入另一个适合的区域，这个区域可以自由分配空间大小。

而且为CPU配置的一级二级缓存区，其性质正好也被栈所利用。

[堆栈比较好的回答](https://blog.csdn.net/qq_28098067/article/details/53219086)

## String
[实现String](https://www.cnblogs.com/beixiaobei/p/10914267.html)

---
## 智能指针
智能指针和普通指针的区别就在于：智能指针实际上是对普通指针加了一层封装机制，这样一层的封装机制是为了智能指针可以方便的管理一个对象的生命期。

在使用share_ptr时，注意不要循环引用，会导致无法进行析构，可以使用weak_ptr进行补充，weak_ptr引用资源时，不会增加引用计数，可以在循环引用中的一环将shared_ptr变为weak_ptr。weak_ptr没有资源的操作权，因此没有operator*和->，如要操作资源，则必须使用一个非常重要的成员函数lock()从被观测的shared_ptr获得一个可用的shared_ptr对象，从而操作资源。

weak_ptr可以作为弱回调参数，因为其不会增加引用计数，shared_ptr在完成此方面的工作的时候会延长生命周期（std::bind）。

shared_ptr和weak_ptr在主流平台的技术操作时原子操作，所以不用加锁，效率较高。

reset()函数会导致该智能指针托管新的对象，如果原对象引用计数减一变为0.则会执行析构。

[参考](https://zhuanlan.zhihu.com/p/73807983)

[weak_ptr指针图解](https://blog.csdn.net/albertsh/article/details/82286999)

实现一份简易的智能指针
```
include <iostream>
#include <thread>
#include <mutex>///

using namespace std;

template<class T>
class SharedPtr{
public:
	SharedPtr(T* ptr = nullptr)
		: _ptr(ptr)
		, _pCount(new int(1))
		, _pMutex(new mutex)
	{
		// 如果是一个空指针对象，引用计数给0
		if (_ptr == nullptr)
			*_pCount = 0;
	}

	SharedPtr(SharedPtr<T>& copy)
		: _ptr(copy._ptr)
		, _pCount(copy._pCount)
		, _pMutex(copy._pMutex)
	{
		if (_ptr)
			AddCount();
	}

	SharedPtr<T>& operator=(const SharedPtr<T>& copy)
	{
		// 防止自赋值
		if (_ptr != copy_ptr){
			// 释放_ptr旧资源
			Release();

			// 共享copy对象资源
			_ptr = copy._ptr;
			// 计数增加
			_pCount = copy._pCount;
			_pMutex = copy._pMutex;

			if (_ptr)
				AddCount();
		}
		return *this;
	}

	T& operator*() { return *_ptr; }
	T& operator->() { return _ptr; }

	// 查看当前计数
	int UseCount() { return *_pCount; }

	// 获取原始指针
	T* Get(){ return _ptr; }

	// 如果有新对象，增加引用计数
	int AddCount()
	{
		// 为保证多线程下的线程安全，执行锁操作
		_pMutex->lock();

		++(*_pCount);
		_pMutex->unlock();
		return *_pCount;
	}

	// 如果有对象调用析构，减少引用计数
	int SubCount()
	{
		_pMutex->lock();

		--(*_pCount);
		_pMutex->unlock();
		return *_pCount;
	}

	~SharedPtr()
	{
		Release();
	}

private:
	// 释放资源
	void Release()
	{
		// 如果引用计数减为0，则释放资源
		if (_ptr && SubCount() == 0){
			delete _ptr;
			delete _pCount;
		}

	}

private:
	int* _pCount;  // 引用计数
	T* _ptr;  // 指向管理资源的指针
	mutex* _pMutex;  // 互斥锁
};

int main()
{
	SharedPtr<int> sp1(new int(10));
	cout << "Before Add SP2：" << sp1.UseCount() << endl;
	SharedPtr<int> sp2(sp1);
	cout << "After Add SP2：" << sp1.UseCount() << endl;

	return 0;
}
```
