## 初始化
**初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来代替**

定义在函数体内部的内置类型变量将不被初始化。

## explicit关键字
针对类的构造函数是默认进行隐式转换的情况，可以使用`explicit`进行改变。

[链接](https://blog.csdn.net/guoyunfei123/article/details/89003369)

## NULL和nullptr
在c语言中，NULL既可以是0也可以是(void*)0

但在c++中，这样会给函数重载带来困扰，造成歧义。

于是c++规定，在C++中，NULL只能代表整数0，而（void*)0则有nullptr代表，nullptr只代表空指针，不能表示整数0。其实就是把整数0和(void*)0，分开表示。

## 指针和引用的区别
引用需要初始化，且之后无法改变，**引用并非一个对象**

## Const
如果想在多个文件之间共享`const`对象，必须在变量的定义之前添加`extern`关键字。
在对`const`对象编译时，编译器会将所有用到该变量的地方都替换成对应的值。

const的引用，const引用只能引用常量对象。

引用的例外1：在初始化常量引用时允许用任意表达式作为初始值，只要该表达式能转换成引用的类型即可。这是因为编译器在处理常量引用类型的时将
```
const int &ri = dval;
变成了
const int temp = dval;
const int &ri = temp;
```
在这种情况下，常量引用实际上是绑定的一个临时量，所以可以使用任意可以转化为该类型的表达式，而非常量引用如果类型不同的话，参照上面的代码，实际上是引用的其他对象，这跟引用的初衷违背。

可以使用const修饰引用变量去引用一个非const对象，但是无法在在这个const引用上做更改。

const指针，常量指针需要初始化，并且不能修改其所指向的地址，但是其所指向的地址中的值如果不是常量的话则可以修改。
```
const int i = 1;
const int *curr = &i //curr是一个指针，指向一个int类型的常量
const int t =2;
curr = &t;//因为只是一个指针而已，所以可以改变指向的对象


const int i = 1;
const int *const curr = &i  //curr是一个常量指针，指向的是一个int类型的常量
const int j = 2;
curr = &j;//错误，因为是这个指针是被const修饰的，所以不能改变指向

```

底层const拷贝注意
```
const int v2 = 0; int v1 = v2;
int *p1 = &v1, &r1 = v1;
const int *p2 = &v2, *const p3 = &v2,&r2 = v2;

r1 = v2//值赋值，顶层可以

p1 = p2//p1是指向int的指针，而p2则是const int的指针，赋值给p1是会被改变的

p2=p1//顶层可以

p1 = p3;
p3 = p1
```

## constexpr
当认定一个变量是一个常量表达式，那就把它声明成为constexpr类型。并且constexpr把它所定义的对象置为了顶层const

## 指针、常量和类型别名
如果某个类型别名指代的是符合类型或常量，那么把它用到声明语句就会产生不同的效果，pstring是个类型别名,应该把它当成一个类型来看待,很显然pstring是一个指针类型,而const修饰的正是它,也就是说const修饰的是指针,所以这是个cstar是一个常量指针,这个常量指针指向一个char.

## auto
auto定义的变量，会自动忽略顶层const，在引用类型中，原来的初始化规则（顶层const）仍然适用。

## 数组和指针
```
int *p = arr;
int (*Parray)[10] = &arr;Parrray指向一个含有十个整数的数组
int (&arrRef)[10] = arr; arrRef引用一个含有十个整数的数组
(*Parray)[1]
*p或者p[1]都行
```

## 类型判断
**如果是数组的类型判断的话，从内向外读，如果是其他类型的话，从右向左读。**

## 左值和右值
当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。

复合表达式满足优先级和结合律

## 为什么会有const_cast改变底层的const
应用场景一般是接口参数类型不同，但是明确知道不会改变的时
候。也是与老版本的C库兼容
[const_cast](https://www.zhihu.com/question/19772701/answer/20426924)

## 封装
封装有两个重要的优点：
- 确保用户代码不会无意间破坏封装对象的状态。
- 被封装的类的具体实现细节可以随时改变，而无需调整用户级别的代码。

如果数据定义为public的，则所用使用了原来数据成员的代码都有可能失效，这时必须重写。并且可以防止用户破坏。

## mutable
当一个函数不会改变对象的状态时，可以将这个函数声明为const，但如果需要在函数中修改一些和类状态无关的成员，就要用到mutalbe，尽管函数被const修饰，但是还是可以被修改。

## 初始化列表
如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始化列表为这些成员提供初始值。初始化列表的顺序是按照定义的顺序来进行初始化的。

## static关键字

### 修饰非类成员函数
对于两个不同文件，在不知情的情况下，如果存在两个同名函数的话，如果文件A引用了文件B，这样会造成编译不通过，这是因为普通函数具有全局可见性，所以在非类中，`static`修饰的函数通常作为隐藏作用使用。

### 修饰非类成员变量
`static`关键字修饰的变量会在程序开始前就进行了初始化，并且就算是局部变量，也只会在程序结束时才会释放内存，**但是需要注意的是，static的局部变量还是有一个可见范围，在作用域之外是无法访问的。**

**static变量也会默认初始化为0值**

### 修饰对象中的成员时
这时表明这是类的静态成员，不是类的对象的成员，所以它没有this指针，这也导致了它只能访问类的静态数据和静态成员变量。

注意
- 不能将静态成员函数定义为虚函数
- 静态成员变量必须进行初始化
