## 访问控制
- `Private`：私有级别，只允许
  1. 该类中的函数访问
  2. 该类的友元中的函数访问
- `Protected`:保护级别，只允许
  1. 该类中的函数访问
  2. 子类中的函数访问
  3. 友元中的函数访问
- `Public`：公有级别，允许
  1. 该类中的函数访问
  2. 子类中的函数访问
  3. 友元中的函数访问
  4. 类的对象访问

  注意：友元包括三种：设为友元的普通非成员函数；设为友元的其他类的成员函数；设为友元类的所有成员函数。

类继承后方法属性的变化：
- 使用`Private`继承：父类的`Public`和`Protected`在子类中变为`Private`。
- 使用`Protected`继承：父类的`Public`和`Protected`在子类中变为`Protected`。
- 使用`Public`继承：父类中的`Public`和`Protected`在子类中不改变。
- 切记将成员变量声明为`Private`。这可赋予客户访问数据的一致性、可细微划分访问控制、允许约束，并提供弹性。
- `protected`和`public`在某种意义上是一样的。

**虚继承：虚继承是为解决多重继承潜在问题而诞生的，其虚继承类中有虚基表，作用和虚函数表类似，子类中只会存在一份基类的拷贝**

## 初始化
**初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来代替**

定义在函数体内部的内置类型变量将不被初始化。

## explicit关键字
针对类的构造函数是默认进行隐式转换的情况，可以使用`explicit`使其关闭默认转变。

[链接](https://blog.csdn.net/guoyunfei123/article/details/89003369)

## NULL和nullptr
在c语言中，NULL既可以是0也可以是(void*)0

但在c++中，这样会给函数重载带来困扰，造成歧义。

于是c++规定，在C++中，NULL只能代表整数0，而（void*)0则有nullptr代表，nullptr只代表空指针，不能表示整数0。其实就是把整数0和(void*)0，分开表示。

## 指针和引用的区别
引用需要初始化，且之后无法改变，**引用并非一个对象**

## Const
如果想在多个文件之间共享`const`对象，必须在变量的定义之前添加`extern`关键字。
在对`const`对象编译时，编译器会将所有用到该变量的地方都替换成对应的值。

const的引用，const引用只能引用常量对象。

引用的例外1：在初始化常量引用时允许用任意表达式作为初始值，只要该表达式能转换成引用的类型即可。这是因为编译器在处理常量引用类型的时将
```
const int &ri = dval;
变成了
const int temp = dval;
const int &ri = temp;
```
在这种情况下，常量引用实际上是绑定的一个临时量，所以可以使用任意可以转化为该类型的表达式，而非常量引用如果类型不同的话，参照上面的代码，实际上是引用的其他对象，这跟引用的初衷违背。

可以使用const修饰引用变量去引用一个非const对象，但是无法在在这个const引用上做更改。

const指针，常量指针需要初始化，并且不能修改其所指向的地址，但是其所指向的地址中的值如果不是常量的话则可以修改。
```
const int i = 1;
const int *curr = &i //curr是一个指针，指向一个int类型的常量
const int t =2;
curr = &t;//因为只是一个指针而已，所以可以改变指向的对象


const int i = 1;
const int *const curr = &i  //curr是一个常量指针，指向的是一个int类型的常量
const int j = 2;
curr = &j;//错误，因为是这个指针是被const修饰的，所以不能改变指向

```

底层const拷贝注意
```
const int v2 = 0; int v1 = v2;
int *p1 = &v1, &r1 = v1;
const int *p2 = &v2, *const p3 = &v2,&r2 = v2;

r1 = v2//值赋值，顶层可以

p1 = p2//p1是指向int的指针，而p2则是const int的指针，赋值给p1是会被改变的

p2=p1//顶层可以

p1 = p3;
p3 = p1
```

## constexpr
当认定一个变量是一个常量表达式，那就把它声明成为constexpr类型。并且constexpr把它所定义的对象置为了顶层const

## 指针、常量和类型别名
如果某个类型别名指代的是符合类型或常量，那么把它用到声明语句就会产生不同的效果，pstring是个类型别名,应该把它当成一个类型来看待,很显然pstring是一个指针类型,而const修饰的正是它,也就是说const修饰的是指针,所以这是个cstar是一个常量指针,这个常量指针指向一个char.

## auto
auto定义的变量，会自动忽略顶层const，在引用类型中，原来的初始化规则（顶层const）仍然适用。

## 数组和指针
```
int *p = arr;
int (*Parray)[10] = &arr;Parrray指向一个含有十个整数的数组
int (&arrRef)[10] = arr; arrRef引用一个含有十个整数的数组
(*Parray)[1]
*p或者p[1]都行
```

## 类型判断
**如果是数组的类型判断的话，从内向外读，如果是其他类型的话，从右向左读。**

## 左值和右值
当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。

复合表达式满足优先级和结合律

## 为什么会有const_cast改变底层的const
应用场景一般是接口参数类型不同，但是明确知道不会改变的时
候。也是与老版本的C库兼容
[const_cast](https://www.zhihu.com/question/19772701/answer/20426924)

## 封装
封装有两个重要的优点：
- 确保用户代码不会无意间破坏封装对象的状态。
- 被封装的类的具体实现细节可以随时改变，而无需调整用户级别的代码。

如果数据定义为public的，则所用使用了原来数据成员的代码都有可能失效，这时必须重写。并且可以防止用户破坏。

## mutable
当一个函数不会改变对象的状态时，可以将这个函数声明为const，但如果需要在函数中修改一些和类状态无关的成员，就要用到mutalbe，尽管函数被const修饰，但是还是可以被修改。

## 初始化列表
如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始化列表为这些成员提供初始值。初始化列表的顺序是按照定义的顺序来进行初始化的。

## static关键字

### 修饰非类成员函数
对于两个不同文件，在不知情的情况下，如果存在两个同名函数的话，如果文件A引用了文件B，这样会造成编译不通过，这是因为普通函数具有全局可见性，所以在非类中，`static`修饰的函数通常作为隐藏作用使用。

### 修饰非类成员变量
`static`关键字修饰的变量会在程序开始前就进行了初始化，并且就算是局部变量，也只会在程序结束时才会释放内存，**但是需要注意的是，static的局部变量还是有一个可见范围，在作用域之外是无法访问的。**

**static变量也会默认初始化为0值**

### 修饰对象中的成员时
这时表明这是类的静态成员，不是类的对象的成员，所以它没有this指针，这也导致了它只能访问类的静态数据和静态成员变量。

注意
- 不能将静态成员函数定义为虚函数
- 静态成员变量必须进行初始化

## virtual 关键字
被`virtual`修饰的函数称为虚函数， 普通函数不允许通过父类的指针访问子类的对象，这违背了C++的设计原则，而在现实场景中，要实现运行时多态，采用了虚函数来打破这个规则，**虚函数就是为了允许使用父类指针去调用子类的函数**，一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为“虚”函数。

**虚表是属于类的，而不是属于某一个具体的对象，一个类只需要一个虚表即可。同一个类的所有对象都使用同一个虚表**

为了制定对象的虚表，对象内部包含一个虚表的指针，来指向自己所使用的虚表，为了让每个包含虚表的类的对象都拥有一个虚表指针，编译器在类中添加了一个指针，`*__vptr`，用来指向虚表。这样，当类的对象在创建时便拥有了这个指针，且这个指针的值会自动被设置成指向类的虚表。

当一个指向子类的父类指针调用一个虚函数时，其流程如下：
```
B b;
A *a = &b;
a->foo();
```

1. 首先，根据虚表指针`p->__vptr`来访问对象b对应的虚表。虽然指针a是父类`A*`类型的，但是`*__vptr`是子类的一部分，所以可以通过`p->__vptr`访问到对象对应的虚表。
2. 然后，在虚表中查找所调用的函数对应的条目，由于虚表在编译阶段就可以构造出来，所以根据所调用的函数定位到虚表中对应条目。
3. 最后，根据虚表中的函数指针，调用函数。

**虚函数操作耗时主要体现在查表慢**

[参考](https://blog.csdn.net/yc461515457/article/details/52658589)
