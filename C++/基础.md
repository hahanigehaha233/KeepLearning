## 访问控制
- `Private`：私有级别，只允许
  1. 该类中的函数访问
  2. 该类的友元中的函数访问
- `Protected`:保护级别，只允许
  1. 该类中的函数访问
  2. 子类中的函数访问
  3. 友元中的函数访问
- `Public`：公有级别，允许
  1. 该类中的函数访问
  2. 子类中的函数访问
  3. 友元中的函数访问
  4. 类的对象访问

  注意：友元包括三种：设为友元的普通非成员函数；设为友元的其他类的成员函数；设为友元类的所有成员函数。

类继承后方法属性的变化：
- 使用`Private`继承：父类的`Public`和`Protected`在子类中变为`Private`。
- 使用`Protected`继承：父类的`Public`和`Protected`在子类中变为`Protected`。
- 使用`Public`继承：父类中的`Public`和`Protected`在子类中不改变。
- 切记将成员变量声明为`Private`。这可赋予客户访问数据的一致性、可细微划分访问控制、允许约束，并提供弹性。
- `protected`和`public`在某种意义上是一样的。

**虚继承：虚继承是为解决多重继承潜在问题而诞生的，其虚继承类中有虚基表，作用和虚函数表类似，子类中只会存在一份基类的拷贝**

## 运算符重载
自增运算符的重载规则
```
ite++(0);
ListIter operator++(int){
    ListIter tmp = this;
    ++*(this);
    return tmp;
}

++ite;
ListIter& operator(){
    ite->next();
    return *this;
}

```

## `const`函数为什么不能是`staitc`
因为为了让函数不能改变对象值，传入了`const *this`指针，而`static`是没有this指针的。

## noexcept
作用在函数上，说明该函数不会发生异常，如果被修饰的函数发生了异常，编译器可以直接调用std::terminate()来终止程序的运行。这是因为异常机制会带来一些额外开销，比如函数抛出异常，会导致函数栈被依次地展开（unwind），并依帧调用在本帧中已构造的自动变量的析构函数等。

## Union
该结构会尽可能的少用内存，会使得里面的数据类型使用内存时重叠，该性质可以用来节约内存使用，例如STL中的空间配置器中二级配置器使用了，另外也可以判断处理器的端序问题。

先压栈的是低位的话则是小端，先是高位的话则是大端。读取一个数据的时候从低到高读取。
```
int checkCPU()
{
    {
        union w
        {
            int a;
            char b;
        } c;
        c.a = 1;
        return (c.b == 1);    //小端的话 c.b == 1  否则c.b == 0
    }
}

//Linux中的判断
static union
 {
        char c[4];
        unsigned long mylong;
} endian_test = {{ 'l', '?', '?', 'b' } };

#define ENDIANNESS ((char)endian_test.mylong)
```

## 初始化
**初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来代替**

定义在函数体内部的内置类型变量将不被初始化。

## explicit关键字
针对类的构造函数是默认进行隐式转换的情况，可以使用`explicit`使其关闭默认转变。

[链接](https://blog.csdn.net/guoyunfei123/article/details/89003369)

## NULL和nullptr
在c语言中，NULL既可以是0也可以是(void*)0

但在c++中，这样会给函数重载带来困扰，造成歧义。

于是c++规定，在C++中，NULL只能代表整数0，而（void*)0则有nullptr代表，nullptr只代表空指针，不能表示整数0。其实就是把整数0和(void*)0，分开表示。

## 指针和引用的区别
引用需要初始化，且之后无法改变，**引用并非一个对象**

## Const
如果想在多个文件之间共享`const`对象，必须在变量的定义之前添加`extern`关键字。
在对`const`对象编译时，编译器会将所有用到该变量的地方都替换成对应的值。

const的引用，const引用只能引用常量对象。

引用的例外1：在初始化常量引用时允许用任意表达式作为初始值，只要该表达式能转换成引用的类型即可。这是因为编译器在处理常量引用类型的时将
```
const int &ri = dval;
变成了
const int temp = dval;
const int &ri = temp;
```
在这种情况下，常量引用实际上是绑定的一个临时量，所以可以使用任意可以转化为该类型的表达式，而非常量引用如果类型不同的话，参照上面的代码，实际上是引用的其他对象，这跟引用的初衷违背。

可以使用const修饰引用变量去引用一个非const对象，但是无法在在这个const引用上做更改。

const指针，常量指针需要初始化，并且不能修改其所指向的地址，但是其所指向的地址中的值如果不是常量的话则可以修改。
```
const int i = 1;
const int *curr = &i //curr是一个指针，指向一个int类型的常量
const int t =2;
curr = &t;//因为只是一个指针而已，所以可以改变指向的对象


const int i = 1;
const int *const curr = &i  //curr是一个常量指针，指向的是一个int类型的常量
const int j = 2;
curr = &j;//错误，因为是这个指针是被const修饰的，所以不能改变指向

```

底层const拷贝注意
```
const int v2 = 0; int v1 = v2;
int *p1 = &v1, &r1 = v1;
const int *p2 = &v2, *const p3 = &v2,&r2 = v2;

r1 = v2//值赋值，顶层可以

p1 = p2//p1是指向int的指针，而p2则是const int的指针，赋值给p1是会被改变的

p2=p1//顶层可以

p1 = p3;
p3 = p1
```

## constexpr
当认定一个变量是一个常量表达式，那就把它声明成为constexpr类型。并且constexpr把它所定义的对象置为了顶层const

## 指针、常量和类型别名
如果某个类型别名指代的是符合类型或常量，那么把它用到声明语句就会产生不同的效果，pstring是个类型别名,应该把它当成一个类型来看待,很显然pstring是一个指针类型,而const修饰的正是它,也就是说const修饰的是指针,所以这是个cstar是一个常量指针,这个常量指针指向一个char.

## auto
auto定义的变量，会自动忽略顶层const，在引用类型中，原来的初始化规则（顶层const）仍然适用。

## 数组和指针
```
int *p = arr;
int (*Parray)[10] = &arr;Parrray指向一个含有十个整数的数组
int (&arrRef)[10] = arr; arrRef引用一个含有十个整数的数组
(*Parray)[1]
*p或者p[1]都行
```

## 类型判断
**如果是数组的类型判断的话，从内向外读，如果是其他类型的话，从右向左读。**

## 左值和右值
当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。

左值可以被作为左值和右值，右值只能作为右值。

在左值被作为左值时，使用的是地址，被作为右值时，使用的是其地址上的值。

### 右值引用
[C++右值引用 - 小小将的文章 - 知乎](https://zhuanlan.zhihu.com/p/54050093)

右值引用即可以引用右值，也可以引用左值，其目的就是将该引用对象的资源进行利用，使得不用再构造额外的临时对象，对被引用对象所做的一切都会真实反映在该对象上。

```
int a = 1;
int&& b = a;//非法，a在这里被使用的是左值也就是读取的是其地址
int&& c = a+1;//合法，a+1的结果被c右值引用
```
### 移动构造函数
移动构造函数和移动赋值函数都是通过右值引用来完成的，如
```
DynamicArray(DynamicArray&& rhs) :
        m_size{ rhs.m_size }, m_array{rhs.m_array}
    {
        rhs.m_size = 0;
        rhs.m_array = nullptr;
        cout << "Move constructor: dynamic array is moved!\n";
    }
```
这样便节省了一次构造函数调用。析构函数依然会调用，因为临时对象rhs依然存在，不过只是一具空壳。

std::move()就是对右值引用移动的封装，在上面代码中我们需要手动设置nullptr，使用了std::move()就行了。

## 为什么会有const_cast改变底层的const
应用场景一般是接口参数类型不同，但是明确知道不会改变的时
候。也是与老版本的C库兼容
[const_cast](https://www.zhihu.com/question/19772701/answer/20426924)

## 封装
封装有两个重要的优点：
- 确保用户代码不会无意间破坏封装对象的状态。
- 被封装的类的具体实现细节可以随时改变，而无需调整用户级别的代码。

如果数据定义为public的，则所用使用了原来数据成员的代码都有可能失效，这时必须重写。并且可以防止用户破坏。

## mutable
当一个函数不会改变对象的状态时，可以将这个函数声明为const，但如果需要在函数中修改一些和类状态无关的成员，就要用到mutalbe，尽管函数被const修饰，但是还是可以被修改。

在muduo中，对于一个get()函数，get本身是不会改变的，所以函数使用了const进行修饰，但是如果要对其加一个互斥锁的话，就不能const，所以办法是对互斥变量mutex声明为mutable。

## 初始化列表
如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始化列表为这些成员提供初始值。初始化列表的顺序是按照定义的顺序来进行初始化的。

## static关键字

### 修饰非类成员函数
对于两个不同文件，在不知情的情况下，如果存在两个同名函数的话，如果文件A引用了文件B，这样会造成编译不通过，这是因为普通函数具有全局可见性，所以在非类中，`static`修饰的函数通常作为隐藏作用使用。

### 修饰非类成员变量
`static`关键字修饰的变量会在程序开始前就进行了初始化，并且就算是局部变量，也只会在程序结束时才会释放内存，**但是需要注意的是，static的局部变量还是有一个可见范围，在作用域之外是无法访问的。**

**static变量也会默认初始化为0值**

### 修饰对象中的成员时
这时表明这是类的静态成员，不是类的对象的成员，所以它没有this指针，这也导致了它只能访问类的静态数据和静态成员变量。

注意
- 不能将静态成员函数定义为虚函数
- 静态成员变量必须进行初始化

## virtual 关键字
被`virtual`修饰的函数称为虚函数， 普通函数不允许通过父类的指针访问子类的对象，这违背了C++的设计原则，而在现实场景中，要实现运行时多态，采用了虚函数来打破这个规则，**虚函数就是为了允许使用父类指针去调用子类的函数**，一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为“虚”函数。

**虚表是属于类的，而不是属于某一个具体的对象，一个类只需要一个虚表即可。同一个类的所有对象都使用同一个虚表**

为了制定对象的虚表，对象内部包含一个虚表的指针，来指向自己所使用的虚表，为了让每个包含虚表的类的对象都拥有一个虚表指针，编译器在类中添加了一个指针，`*__vptr`，用来指向虚表。这样，当类的对象在创建时便拥有了这个指针，且这个指针的值会自动被设置成指向类的虚表。

当一个指向子类的父类指针调用一个虚函数时，其流程如下：
```
B b;
A *a = &b;
a->foo();
```

1. 首先，根据虚表指针`p->__vptr`来访问对象b对应的虚表。虽然指针a是父类`A*`类型的，但是`*__vptr`是子类的一部分，所以可以通过`p->__vptr`访问到对象对应的虚表。
2. 然后，在虚表中查找所调用的函数对应的条目，由于虚表在编译阶段就可以构造出来，所以根据所调用的函数定位到虚表中对应条目。
3. 最后，根据虚表中的函数指针，调用函数。

**虚函数操作耗时主要体现在查表慢**

对于非多态类对象在虚拟继承中的存取，编译器可能存在不同的做法，见《深度探索C++模型》P129

[参考](https://blog.csdn.net/yc461515457/article/details/52658589)

## 模板
当编译器遇到一个模板定义时，它并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码。所以编译错误大多数是在实例化期间。

## pragma once和预处理的区别
ifndef方式依赖于宏名不能冲突。它不光可以保证同一个文件不会被包含多次，也能保证内容完全相同的两个文件不会被不小心同时包含。缺点是如果不同头文件中的宏名不小心”碰撞”，可能就会导致你看到头文件明明存在，编译器却硬说找不到声明的状况。

## 类中的`sizeof`
空类的大小为1字节，因为如果没有的话实例无法区分，所以产生了空基类最优化方法，将需要继承的非虚函数，typedef，static变量放入基类中达到继承并且减少内存消耗的效果。


## 堆栈区别
产生堆和栈两个内存区域的原因是因为：程序对处理的数据的要求不同，对于某一些作用时间短，不必共享的变量，需要频繁访问，程序可以放在一个区域，这个区域有专门的寄存器和指令进行操作，而且连续，不容易发生缺页中断；而对于一些其他的，体积大、生命周期长的，不需要频繁访问的，需要放入另一个适合的区域，这个区域可以自由分配空间大小。

而且为CPU配置的一级二级缓存区，其性质正好也被栈所利用。

[堆栈比较好的回答](https://blog.csdn.net/qq_28098067/article/details/53219086)

---
## 智能指针
智能指针和普通指针的区别就在于：智能指针实际上是对普通指针加了一层封装机制，这样一层的封装机制是为了智能指针可以方便的管理一个对象的生命期。

在使用share_ptr时，注意不要循环引用，会导致无法进行析构，可以使用weak_ptr进行补充，weak_ptr没有资源的操作权，因此没有operator*和->，如要操作资源，则必须使用一个非常重要的成员函数lock()从被观测的shared_ptr获得一个可用的shared_ptr对象，从而操作资源。[参考](https://zhuanlan.zhihu.com/p/73807983)

实现一份简易的智能指针
```
template <class T>
class SmartPoint{
  protected:
      T* ptr;
      int* count;


  protected:
      //默认构造函数
      SmartPoint(T* p):ptr(p),count(new int(1))
      {

      }
      //拷贝构造函数
      SmartPoint(SmartPoint& p):count((++*(p.count)))
      ,ptr(p.ptr)
      {

      }
      ~SmartPoint(){
        if(--*(this->count) == 0){
          delete this->ptr;
          delete this->count;
        }
      }
      //->操作符
      T* operator->(){
        return this->ptr;
      }
      //解引用
      T& operator*(){
        return *(this->ptr);
      }
      //赋值运算符
      SmartPoint& operator=(SmartPoint& p){
        if(this->ptr == p.ptr) return *this;
        ++*(p.count);
        if(--*count == 0){
          delete ptr;
          delete count;
        }
        this.count = p.count;
        this.ptr = p.ptr;
        return *this;
      }
}
```
