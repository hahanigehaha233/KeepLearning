## LevelDB篇

#### 1-1 父类是子类的友元类
```
class DBImpl : public DB{
  private：
    friend class DB;
}

```
在本代码中，父类中全为`Public`申明的函数，所以应该是遗留下来的代码，这样做的目的是子类去使用一些父类的私有成员，并且这些私有成员不想被所有子类继承。

#### 1-2 `__attribute__((visibility("default")))`

全局符号介入：当一个符号需要被加入全局符号表中，如果相同的符号名已经存在，则后加入的符号被忽略。正是因为这样的原因，所以在对第一类（模块内部函数调用和跳转时）的处理时，动态链接器选择了把它当做外部符号进行处理，（因为如果采用相对地址，假设模块内函数因为全局符号介入被同名函数覆盖，采用相对地址的函数就需要被重新定位，这与共享对象的地址无关性相矛盾），可以在编译时使用参数`fvisibility=hidden`设置符号默认隐藏，再在需要的地方使用代码`__attribute__((visibility("default")))`使得符号外部可见。[参考](https://www.cnblogs.com/bugutian/articles/4746946.html)


###  锁的封装 RAII概念
使用局部变量的性质封装Mutex互斥量，达到作用域结束自动释放的效果。
```
class SCOPED_LOCKABLE MutexLock {
 public:
  explicit MutexLock(port::Mutex* mu) EXCLUSIVE_LOCK_FUNCTION(mu) : mu_(mu) {
    this->mu_->Lock();
  }
  ~MutexLock() UNLOCK_FUNCTION() { this->mu_->Unlock(); }

  MutexLock(const MutexLock&) = delete;
  MutexLock& operator=(const MutexLock&) = delete;

 private:
  port::Mutex* const mu_;
};
```

RAII的全称是“Resource Acquisition is Initialization”，直译过来就是“资源获取即初始化”，也就是在构造函数中分配资源，在析构函数中释放资源。

一个典型的应用就是在线程同步中，使用`std::unique_lock`或者`std::lock_gurad`对互斥量`std::mutex`进行状态管理。因为传统的写法
```
lock(&mutex)
do somethings
unkock(&mutex)
```
在中间执行过程中可能导致异常退出，互斥量便得不到释放，可以使用` std::lock_guard<std::mutex> lock(mutex_)`一行代码进行代替。

智能指针`share_ptr`也是一个例子。[参考](https://blog.csdn.net/GangStudyIT/article/details/80645399)

[Weak_ptr](https://blog.csdn.net/albertsh/article/details/82286999)

weak_ptr中只有函数lock和expired两个函数比较重要，因为它本身不会增加引用计数，所以它指向的对象可能在它用的时候已经被释放了，所以在用之前需要使用expired函数来检测是否过期，然后使用lock函数来获取其对应的shared_ptr对象，然后进行后续操作：

---

## Effective C++

### 条款05：C++类中默认生成的函数
- `default`构造函数
- `copy`构造函数
- 析构函数
- `copy assignment`操作符

这些函数都是`public`的且是`inline`的。

注意：**当你自己构造了一个有参数的构造函数后，编译器就不会为它再创建一个`default`构造函数，可以用`delete`关键字取消默认函数**

`copy assignment` 也就是`=`操作符，在以下情况下是不会默认创建的
- 类中含有引用。
- 类中含有`const`修饰的变量。
- `base class`的`copy assignment`申明为`private`权限的。

### 条款06：如何避免默认生成的函数
方法一：**申明** 函数并且设置为`Private`。

缺点:这种方式如果在友元函数中不慎调用，连接器是会报错,我们在编写代码的时候，**尽量将错误从连接期移至编译期，尽早发现**

方法二：编写一个`base class`并且将其中的`copy assignment`设置为`private`，再在具体的`derived class`中继承，当其友元不慎调用，也可以在编译期及时发现问题。

### 条款07：为多态基类申明`virtual`析构函数
使用虚特性的时候，在父类指针指向了子类的对象时，如果其析构函数不是虚函数的话，可能会造成内存泄露，析构函数也需要拥有虚特性。

含有虚函数的类中会占用额外的内存空间，进行存储`vptr`指针，所以在没有必要使用虚特性的时候，不需要将函数申明为虚函数。

### 条款02：使用`const、enum、inline`替换 `#define`
因为`#define`属于预处理阶段，例如：`#define PI 3.14`，如果在编译器出错的话，由于`PI`这个变量没有进入符号表，错误信息只会提示3.14，如果这是其他人的代码的话，理解上会有很大的困难。

- `#define`定义的常量没有所谓的作用域的概念。也就是不能用来定义专属常量。所以最好用const或者enum代替。
- `#define`形式的宏，最好改用inline函数替换。
