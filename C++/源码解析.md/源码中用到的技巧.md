## LevelDB篇

#### 1-1 父类是子类的友元类
```
class DBImpl : public DB{
  private：
    friend class DB;
}

```
在本代码中，父类中全为`Public`申明的函数，所以应该是遗留下来的代码，这样做的目的是子类去使用一些父类的私有成员，并且这些私有成员不想被所有子类继承。

#### 1-2 `__attribute__((visibility("default")))`

全局符号介入：当一个符号需要被加入全局符号表中，如果相同的符号名已经存在，则后加入的符号被忽略。正是因为这样的原因，所以在对第一类（模块内部函数调用和跳转时）的处理时，动态链接器选择了把它当做外部符号进行处理，（因为如果采用相对地址，假设模块内函数因为全局符号介入被同名函数覆盖，采用相对地址的函数就需要被重新定位，这与共享对象的地址无关性相矛盾），可以在编译时使用参数`fvisibility=hidden`设置符号默认隐藏，再在需要的地方使用代码`__attribute__((visibility("default")))`使得符号外部可见。[参考](https://www.cnblogs.com/bugutian/articles/4746946.html)

---

## Effective C++

### 条款05：C++类中默认生成的函数
- `default`构造函数
- `copy`构造函数
- 析构函数
- `copy assignment`操作符

这些函数都是`public`的且是`inline`的。

注意：**当你自己构造了一个有参数的构造函数后，编译器就不会为它再创建一个`default`构造函数**

`copy assignment` 也就是`=`操作符，在以下情况下是不会默认创建的
- 类中含有引用。
- 类中含有`const`修饰的变量。
- `base class`的`copy assignment`申明为`private`权限的。

### 条款06：如何避免默认生成的函数
方法一：**申明** 函数并且设置为`Private`。

缺点:这种方式如果在友元函数中不慎调用，连接器是会报错,我们在编写代码的时候，**尽量将错误从连接期移至编译期，尽早发现**

方法二：编写一个`base class`并且将其中的`copy assignment`设置为`private`，再在具体的`derived class`中继承，当其友元不慎调用，也可以在编译期及时发现问题。
