## 内存布局
Linux默认情况下将高地址的1GB空间分配给内核，用户使用剩下的3GB的内存空间称为用户空间。在用户空间中，也有许多地址区间有特殊的地位，一般来讲，应用程序使用的内存空间里有如下默认区域：
- 栈：栈用于维护函数调用的上下文，离开了栈函数调用就无法实现。栈通常在用户空间的最高地址处分配，通常有数兆字节大小。
- 堆：堆是用来容纳应用程序动态分配的内存区域，当程序使用malloc或new分配内存时，得到的内存来自堆里。堆通常存在于栈的下方，一般比栈大很多。
- 可执行文件映像：这里存储着可执行文件在内存里的映像，由装载器在装载时将可执行文件的内存读取到这里。
- 保留区：保留区并不是一个单一的内存区域，二十对内存中受到保护而禁止访问的内存区域的总称。
- 动态链接库区：用于映射装载的动态链接库。

### 栈
栈在程序运行中具有举足轻重的地位，最重要的，栈保存了一个函数调用所需要的维护信息，这常常被称为**堆栈帧**或者是**活动记录**。一般记录了如下几个方面的内容。
- 函数的返回地址和参数。
- 临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量。
- 保存的上下文：包括在函数调用前后需要保持不变的寄存器。

栈调用最关键的就是ebp指针和esp指针的位置，其中，ebp在每一个帧中位置不变，这样可以用来定位函数活动的各个数据，esp始终指向了栈顶，一个函数的调用操作基本为。
1. 把所有或一部分参数压入栈中，如果有其他参数没有入栈，那么使用某些特定的寄存器传递。
2. 把当前指令的下一条指令压入栈中。
3. 跳转到函数体中执行。

而在函数体中执行的话。
1. push ebp，将调用函数的ebp压入栈中。
2. mov ebp,esp：让新的ebp指向esp

把ebp压入栈中，是为了在函数返回的时候便于恢复以前的ebp值。函数返回时。

1. mov esp,ebp 恢复esp同时回收局部变量空间。
2. pop ebp 从栈中恢复ebp保存的值
3. ret 从栈中取出返回值，并跳转到该位置。

函数进入和退出指令，基本形式为：
```
push ebp
mov ebp, esp
sub esp, x
[push reg1]
...
[push regn]

函数实际内容

[pop regn]
...
[pop reg1]
mov esp,ebp
pop ebp
ret
```
其中，x为栈上开辟出来的临时空间的字节数，reg1...regn分别代表需要保存的n个寄存器。

函数调用的时候，会将返回地址和old ebp，局部变量和寄存器变量都压入栈中，当函数运行完成之后，局部变量和寄存器变量空间释放，ebp弹出，返回下一条指令执行。

这些都是调用惯例进行规定的。

#### 返回对象过大的情况
1. 当返回一个大于8个字节的对象的时候，eax和edx无法存放，在函数调用的时候，会在栈上额外开辟一片空间，并将这块空间的一部分作为传递返回值的临时对象，这里称为temp
2. 将temp对象的地址作为隐藏参数传递给return_test函数
3. return_test函数将数据拷贝给temp对象，并将temp对象的地址用eax传出
4. return_test返回后，函数将eax指向temp对象的内容拷贝给n

结论是，如果返回值类型的尺寸太大，C语言在函数返回时会使用一个临时的栈上内存区域作为中转，结果返回值对象会被拷贝两次。

## 堆
光有栈对于面向过程的程序设计还远远不够，因为栈上的数据在函数返回的时候就会被释放掉，所以无法将数据传递至函数外部。一般由运行库像操作系统申请足够的内存空间，不必每次malloc都像操作系统直接请求。

申请内存可以通过mmap函数进行申请，它的作用是向操作系统申请一段虚拟地址空间，如果不将他映射到某个文件中时，就是当堆空间使用。

**malloc申请的空间可能是不连续的物理页拼凑而成的**

堆分配算法主要有空闲链表和位图两种


---

## 内存问题
#### 缓冲区溢出
用std::vector<char>/std::string或自己编写Buffer class来管理缓冲区，自动记住用缓冲区的长度，并通过用成员函数并不是裸指针来修改缓冲区。

#### 空/野指针
使用share_ptr和weak_ptr。

#### 重复释放
使用scoped_ptr，只会在对象析构的时候释放一次。

#### 内存泄漏
同上

#### 不配对的new/delete
将new
