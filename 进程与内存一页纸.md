## 进程内存一页纸

**进程fork**：分配新的地址空间。这两个进程拥有相同的文本段，不同的堆栈，数据段，会复制父进程的文件描述符，也会复制锁，所以可能导致死锁的发生。但是都只是先只读共享而已，表示进程的结构体task_struct会进行复制，再改变PID和标志。

**vfork**：vfork是为了让子进程快速执行exec而专门设立的，vfork共享父进程的内存，直到其调用的exec，并且在这之前，将暂停执行父进程。exec是会启动参数指定的程序，代替自身进程。因为是共享的，如果在vfork和exec之间执行了修改代码，是可能引发段错误的。

**孤儿和僵尸**：wait()，getppid = 1,init接手并释放；父进程没有及时，保留状态，pid，可以wait

**死锁**：1.资源互斥。2.不可剥夺。3.请求和保持。4.循环等待

**内核态和用户态**：多的几个汇编指令状态。信任问题。1.寄存器，内核栈。2.编号。3.sys_call_table。4.返回

**进程切换和线程切换**：都要内核态，1.页表。2.内核态。3.寄存器上下文。软性开销--缓存。

**进程通信**：传输：1.字节流，socket，管道。2.消息队列。3.共享内存和内存映射

**同步**：信号量，互斥体，条件变量，文件锁

---

**malloc**：将堆分块，大小各一，双向链表，太大使用mmap映射。头结构：是否使用，大小，所属方法。

**static**：1.静态成员变量，全局数据区。初始化时分配。2.静态成员函数，无this指针，无法访问非静态成员。3.全局变量，可见性。4.局部变量，申明处仅一次初始化。
