### 事务
#### 事务特性
- 原子性(A)：事务时最小单位，不可再分的。
- 一致性( C): 事务要求所有的DML语句在操作的时候，要么同时成功，要么同时失败。
- 隔离性(I): 事务A和事务B直接具有隔离性。
- 持久性(D): 是事务的保证，事务终结的保证（内存的数据持久到硬盘文件中）。

#### 事务属性
- 事务是一个最小的，不可再分的工作单元；通常事务对应一个完整的业务功能
- 一个完整的业务需要批量的DML（insert、update、delete）语句共同完成
- 事务只和DML语句有关，或者说DML语句才有事务。这个和业务逻辑有关，业务逻辑不同，DML语句的个数也不同

#### 事务的隔离级别
在这之前需要先了解几种读取情况：
- 脏读：一个事务在处理的过程中读取了另外一个事务未提交的改动。
- 不可重复读：记录（一行或多行）的值在同一次事务中出现两个不同的结果。不同的结果。
- 幻读：同一事务中查询两次得到两个不同的结果集。侧重于多或者少。

MVCC概念：

英文全称为Multi-Version Concurrency Control,翻译为中文即 多版本并发控制。
Innodb实现MVCC的方法是对每一行数据增加了创建时间和删除时间进行控制。

read view其实就是一个保存事务ID的list列表。记录的是本事务执行时，MySQL还有哪些事务在执行。

- Read Repeatable(下文和图中用RR表示)对应的是在每个事务启动的时候创建 一个Read View。

- Read Commit(下文和图中用RC表示)对应的是每次执行SQL statement时候创建 一个Read View。

1. 串行化(Serializable):花费最高的代价但是是最可靠的事务隔离级别。

读写都会增加行级的排他锁（只有这个级别会加读锁），后面的事务必须等到前面的事务操作完成之后才能进行。事务之间100%进行隔离。**对操作的整张表增加排他锁，直到事务提交**

2. 可重复读(Repeatalbe read):默认的隔离级别，当事务A在读取一条数据之后，此时事务B对数据进行了修改并提交，当事务A再读取时，读取到的还是原来的内容。不能避免幻读，但是可以避免脏读和不可重复读。**在读取之前（不是在事务开始时）增加一个ReadView，后面就一直沿用（但是在修改时可见）**

3. Read committed(读已提交):保证一个事务提交之后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。可避免脏读的发生，但是可能会造成不可重复读。**每次读的时候生成一个ReadView**

实现RC的原理排他锁和MVCC， 写时加入排他锁直到事务结束，读时通过MVCC，访问创建版本最大和删除版本为空的记录，针对事务T1和T2

<div align=center>

| T1 | T2 |
-|-
| 查询得到1 | |
| | 修改|
|再次查询得到1| |

</div>

（1） 当T1进行查询的时候，

4. Read uncommitted(读未提交):最低的事务隔离级别，一个事务还没有被提交时，它做的变更就能被其他事务看到。任何情况都可能发生。

实现RU的原理是通过增加排他锁进行的，针对事务T1和T2
<div align=center>

| T1 | T2 |
-| -
| 查询得到1 | |
| | 修改|
|再次查询得到2| |

</div>

（1） 当T1进行查询的时候，并未加任何锁，因此T2可以对数据做修改或查询；

（2） 当T2对数据进行修改时，对数据添加排他锁，完成之后**立即释放**；

（3） 当T1再次查询时，未加任何锁，便会产生脏读；


##### RR等级对幻读的解决
###### 预备知识
- 行锁(Record lock)：单个行记录上的锁；阻塞对行的读写。
- 间隙锁(Gap lock): 锁定索引记录间隙（索引值在某两个索引间隙之间却不存在对的情况），确保索引记录的间隙不变；
- Next-key lock：行锁和间隙锁结合，锁定这个范围的间隙和之间的索引值；

Next-key lock的出现就是为了解决幻读的问题，在操作时加上此锁不允许其他事务进行读写，避免了幻读的情况发生。

#### 参考资料
- [MVCC和ReadView](http://ju.outofmemory.cn/entry/99676)
