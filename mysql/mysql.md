## <center> 数据库基础 </center>



### 主键（Primary key）
主键称为主键约束，在表中是一个列或者列的组合，其值能唯一地标识表中的每一行（unique性质）。
- 每个表中只能包含一个主键；
- 主键值唯一标识表中的每一行，且不能为NULL，即表中不能存在有两行数据相同的主键值，这是唯一性原则；
- 一个列名只能在复合主键中出现一次；
- 复合主键不能包含不必要的列。当把复合主键的某一列删除后，如果剩下的列构成的主键仍然满足唯一性原则，那么这个复合主键是不正确的。这是最小化原则。
- 主键还包含索引性质。
### 唯一键（Unique key）
唯一键可以唯一标识数据库中的每条记录，不同于主键，Unique key在一个表中可以有多个，Unique key会在此列建立一个index。
#### 注意
唯一键值可以为空（即为不填），当不填时，index中便不会有此项，所以在检索时会变慢。

### 外键（Foreign key）
外键的存在会使主表在插入值时进行验证，只有在从表中存在的值才会被成功插入，同理，如果想删除从表中的值，必须先删除主表中相应的值。

---
### 数据库格式
InnoDB存储引擎的逻辑存储结构从大到小依次是表空间、段、页、区、行。
<div align=center>
<img src="../img/逻辑存储单元.png">
</div>

#### 行格式
<div align=center>
<img src="../img/行格式.png">
</div>

- **变长字段长度列表**：该位置用来存储所申明的边长字段中，非空字段实际占有的长度, 例如有三个非空字段,第一个字段长度为3，第二个字段为空,第三个字段为1,则将用01、03标识，为空字段将在下一位置标记，变长字段长度不能超过两个字节，所以varchar 最大长度为65535
- **NULL标志位**：占一个字节，如果列为空则在对应位置上标1，否则标0
- **记录头信息**：固定5个字节，包含下一条记录的位置，该行记录总长度，记录类型，是否被删除，对应的slot信息。
- **列数据**：包含具体的列对应的值，加上两个隐藏的列.

我们需要了解数据页才能直到数据库是怎么从一个数据页中定位到一个数据行中的。因为数据页才是存储引擎管理的最小存储单位，索引只能帮我们定位到某一个数据页。每一次磁盘读写的最小单位也是数据页。

- **文件头**(File Header)：固定38个字节，(页的位置，上一页下一页位置，检查和)
- **数据页头**（page Header）：固定56个字节，包含slot数目，可重用空间起始地址，第一个记录地址、记录数、最大事务ID
- **虚拟的最大最小记录**（Infimum + Supremum record）：
- **用户记录** （User Records）:包含已经删除的记录以链表的形式构成可重用空间
- **待分配空间** （Free spaces） 未分配的空间
- **页目录** （Page Directory） slot 信息，下面单独介绍
- **文件尾**（File Trailer） 固定8个字节,用来保证页的完整性

<div align=center>
<img src="../img/数据库页结构.png">
</div>

页目录里维护多个 slot ，一个 slot 包含多个行记录。每个 slot 占 2 个字节，记录这个 slot 里的行记录相对页初始位置的偏移量。由于索引只能定位到数据页，而定位到数据页内的行记录还需要在内存中进行二分查找，而这个二分查找就需要借助 slot 信息，先找到对应的 slot ，然后在 slot 内部通过数据行中记录头里的下一个记录地址进行遍历。每一个 slot 可以包含 4 到 8 个数据行。如果没有 slot 辅助，链表本身是无法进行二分查找的。
-[数据库页和行结构](https://www.zhihu.com/search?type=content&q=MySQL)

---

### InnoDB存储模型
InnoDB 通过一些列后台线程将相关操作进行异步处理，如下图所示，同时借助缓冲池来减小 CPU 和磁盘速度上的差异。当查询的时候会先通过索引定位到对应的数据页，然后检测数据页是否在缓冲池内，如果在就直接返回，如果不在就去聚簇索引中通过磁盘 IO 读取对应的数据页并放入缓冲池。一个数据页会包含多个数据行。缓存池通过 LRU 算法对数据页进行管理，也就是最频繁使用的数据页排在列表前面，不经常使用的排在队尾，当缓冲池满了的时候会淘汰掉队尾的数据页。从磁盘新读取到的数据页并不会放在队列头部而是放在中间位置，这个中间位置可以通过参数进行修。缓冲池也可以设置多个实例，数据页根据哈希算法决定放在哪个缓冲池。

<div align=center>
<img src="../img/innodb模型.png">
</div>


InnoDB 在更新数据的时候会采用 WAL 技术，也就是（提前写入日志） Write Ahead Logging ，这个日志就是 redolog 用来保证数据库宕机后可以通过该文件进行恢复。这个文件一般只会顺序写，只有在数据库启动的时候才会读取 redolog 文件看是否需要进行恢复。该文件记录了对某个数据页的物理操作，例如某个 sql 把某一行的某个列的值改为 10 ，对应的 redolog 文件格式可能为：把第5个数据页中偏移量为99的位置写入一个值 10 。redolog 不是无限大的，他的大小是可以配置的，并且是循环使用的，例如配置大小为 4G ，一共 4 个文件，每个文件 1G 。首先从第一个文件开始顺序写，写到第四个文件后在从第一个文件开始写，类似一个环，用一个后台线程把 redolog 里的数据同步到聚簇索引上的数据页上。写入 redolog 的时候不能将没有同步到数据页上的记录覆盖，如果碰到这种情况会停下来先进行数据页同步然后在继续写入 redolog 。另外执行更新操作的时候，会先更新缓冲池里的数据页，然后写入 redolog ， 这个时候真正存储数据的地方还没有更新，也就是说这时候缓冲池中的数据页和磁盘不一致，这种数据页称为脏页，当脏页由于内存不足或者其他原因需要丢弃的时候，一定要先将该脏页对应的redolog 刷新到磁盘里的真实数据页，不然下次查询的时候由于 redolog 没有同步到磁盘，而查询直接通过索引定位到数据页就会查询出脏数据。redolog是重复写。       

更新的时候先从磁盘或者缓冲池中读取对应的数据页，然后对数据页里的数据进行更改并生成 redolog　到对应的缓冲池（redolog buffer）进行缓存，当事务提交的时候将缓存写入到　redolog　的物理磁盘文件上。

---
### 配置参数
- **innodb_file_per_table**:配置了该项则每张表都会存储在一个单独的表空间中，没有配置的话默认共享表空间。
- **innodb_page_size**：区在任何时候都是固定为1M。一个区中有多个页，每个页默认为16kb,可以通过参数设置。
- 列的数量不能超过255
- **max_length_for_sort_data**:排序时不取出所有select的字段，而是排序好之后再取出，使用时间换取空间。
- **sort_buffer_size**:控制是否需要借助文件进行归并排序。
- **redolog**:大小可以配置。这个日志就是 redolog 用来保证数据库宕机后可以通过该文件进行恢复。
- **innodb_flush_log_at_trx_commit**：是否在提交的时候强制刷盘，默认为 1 ，事务每次提交都需要调用 fsync 进行刷盘，0 表示事务提交的时候不会调用 redolog　的文件写入，通过后台线程每秒同步一次，2 表示事务提交的时候会写入文件但是只保证写入操作系统缓存，不进行 fsync 操作。redolog 文件只会顺序写，所以磁盘操作性能不会太慢，所以建议生产环境都设置为　１　，以防止数据库宕机导致数据丢失。
- **索引下推**：默认开启
