### 索引
索引的提出是为了加快数据的查询速度，索引分单列索引和组合索引，一个表中可以包含多个单列索引，组合索引的意思是一个索引中包含多个列。实际上，索引也是一张表，并且保存了主键和索引字段，所以这就会造成在更新时的速度降低，当对表进行Insert,update,delete等操作时，不仅要操作原表，也要对索引表进行操作。

**数据库的存储单位是磁盘中的页，这样的设计也是方面在进行磁盘IO时的操作，当一个表中没有建立索引时，其查询是逐个表进行查找的，会消耗线性时间**。

#### 索引原理
磁盘IO时非常耗时的操作，因此在进行磁盘IO时，不光会读取目标地址的数据，也会读取其相邻的数据，这是因为局部预读性原理。但是查询重视伴随着磁盘IO操作，所以我们的目标是尽量少的进行磁盘IO操作，因此索引的数据结构便是使用B+树和哈希进行实现。

##### 最左匹配原理
这是相对于联合索引而言的。**数据库会按照联合索引的顺序建立搜索表**，在查找数据时数据库会按照联合索引中的顺序从左到右进行匹配，当中间有条件缺失或者不确定时（大于符号等）会停止匹配。
- 最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
- =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，
mysql的查询优化器会帮你优化成索引可以识别的形式。

##### 全文索引（带完善）


注意事项：
- MySQL 5.6 以前的版本，只有 MyISAM 存储引擎支持全文索引；
- MySQL 5.6 及以后的版本，MyISAM 和 InnoDB 存储引擎均支持全文索引;
- 只有字段的数据类型为 char、varchar、text 及其系列才可以建全文索引。
- MySQL 中的全文索引，有两个变量，最小搜索长度和最大搜索长度，对于长度小于最小搜索长度和
大于最大搜索长度的词语，都不会被索引。通俗点就是说，想对一个词语使用全文索引搜索，那么
这个词语的长度必须在以上两个变量的区间内。


#### B+树索引
B+树属于平衡树，普通树会在极端情况下退化成线性链表，而B+树采用了额外的操作保证了其
左右子树的高度差不会超过1.因此会在插入和更新时增加耗时，B+树只会在叶子节点上存储数据，
并且作为叶子节点的页会形成一个双向的循环链表，**这样做的目的是提升模糊查询时的速度**。
- B+树索引在遇到=,>,>=,<,<=等操作时是可以使用索引搜索的。
- like也可以使用，只要最开始不是以通配符开始的。

##### MyISAM引擎（非聚集索引）
这种索引方式的索引文件和数据文件是分离的，索引文件仅仅保留数据记录的地址。若以这个引擎创建数据库表（user），它实际上会生成3个文件：
- user.myi 索引文件
- user.myd 数据文件
- user.frm 数据结构类型

当运行 `select * from user where id = 1`它的实际执行流程如下：
- 1. 查看该表的myi文件有没有以id为索引的索引树。
- 2. 根据这个id找到叶子节点的id值，从而得到里面的数据地址。
- 3. 根据数据地址去myd文件中找到对应的数据返回出来。

##### Innodb引擎（聚集索引）
聚集是相对MyISAM引擎而言的，若使用这个引擎创建数据库表（user），它实际上会生成两个文件：
- user.idb 索引文件
- user.frm 数据结构类型

因为在Innodb中，创建表默认以主键为索引（没有主键则寻找满足的列，没有满足的列会自动生成），所以不需要myi文件。此时如果在name字段建立一个索引，其会以name字段为索引值生成一个索引树，`select * from user where name = '吴磊'`时：
- 1. 找到name索引树。
- 2. 根据name的值找到该索引树下的name索引和主键值。
- 3. 通过主键值去主键索引树去叶子节点找到该条信息。

#### 哈希索引
哈希索引就是把索引值通过哈希函数映射成为一个新的哈希值，检索时不需要像B+树一样从根节点到叶子节点逐级查找，只需要一次哈希算法便可以定位到相应的位置，速度非常快。但是缺点也显而易见：
- 哈希索引没有办法通过索引完成排序。
- 不支持最左匹配原则。需要全部使用。
- 冲突在极端情况下是会造成查找时间线性的。
- 哈希值虽然是按照顺序排列，但是实际数据并不是按照顺序排列，所以无法加速排序操作。

##### 覆盖索引
覆盖索引（convering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中取得。如表中有提个索引idx_key1_key2(key1,key2)，当我们使用SQL语句:`select key2 from table where key1=""`就可以通过覆盖索引，无需回表。

### MySQL5.6的索引更新
索引下推技术：可以在有like查询条件下，减少回表的次数。索引下推一般可用于所求查询字段（select列）不是/不全是联合索引的字段，查询条件为多条件查询且查询条件子句（where/order by）字段全是联合索引。我们一般使用explain来查看语句是否使用索引

**InnoDB的主键索引因为是聚集的情况，所以在使用索引下推技术时是减少不了的，但是可以针对二级索引进行优化，通过二级索引下推之后再在主键索引中调出所有行**
#### 参考资料
- [索引介绍/基本操作](https://www.runoob.com/mysql/mysql-index.html)
- [最左匹配原则](https://www.jianshu.com/p/b7911e0394b0)
- [B+树删除操作](https://www.cnblogs.com/wade-luffy/p/6292784.html)
- [哈希索引和B+树索引的区别](https://www.cnblogs.com/zhidongjian/p/10414129.html)
- [MyISBM和Innodb的区别](https://www.cnblogs.com/wlwl/p/9465583.html)

---

##高性能索引
索引是在存储引擎层面实现的，所以没有统一的索引标准；不同存储引擎的索引的工作方式不一样，不是所有的存储引擎都支持所有类型的索引。
- 索引大大减少了服务器需要扫描的数据量
- 索引可以帮助服务器避免排序和临时表
- 索引可以将随机I/O变为顺序I/O

#### 独立的列
指的是索引不能是表达式的一部分。也不能是函数的参数，如
```
SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;
```
这不能使用索引

#### 前缀索引和索引选择性
当索引字段过长时，索引效率会降低，可以适当地截取字符前缀进行索引。

索引选择性是一个索引可以选择的数据条数，当选择性为1时，说明这是最好的。当索引允许重复时，这个数会比较大，可以通过两种方法比较：
- 统计出现次数前几的字符串次数，然后然索引前缀一个一个递增，当数据大致匹配时便得到前缀长度。
- 计算完整列的选择性，并使前缀的选择性接近于完整列的选择性。

**MySQL无法使用前缀索引做GROUP BY和ORDER BY，也无法做覆盖扫描**

#### 多列索引
在多个列上建立单列索引大部分情况下并不能提高MySQL的查询性能，MySQL5.0对其进行了优化，称为索引合并策略。
- 当出现服务器堆多个索引做相交操作时（通常有多个AND），通常意味着需要一个包含所有相关列的多列索引，而不是多个独立的单列索引。
- 当服务区需要对多个索引做联合操作时（通常有多个OR），通常需要耗费大量的CPU资源和内存资源。
- 优化器不会把这些计算到查询成本中，。
