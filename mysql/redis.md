## 1.读写键空间的额外操作
- 读取之后，服务器会根据键是否存在来更新服务器的键空间命中次数（hit）或键空间不命中次数（miss）。
- 在读取一个键之后，服务器会更新键的LRU（最后一次使用时间），这个值可以用来计算键的闲置时间，使用`OBJECT idletime <key>`可以查看键的闲置时间。
- 服务器读取键是发现键过期后，会先删除该键再进行后续操作。
- 如果有客户通过`WATCH`命令坚实了某个键，那么服务器在对被监视的键进行修改之后，会将这个键标记为脏`dirty`,从而让事务程序注意到这个键已经被修改过。
- 脏值增加，持久化和复制操作。
- 数据库通知。

## 键的生存时间
通过`EXPIRE`或者`PEXPIRE`设置生存时间

通过`EXPIREAT`或者`PEXPIREAT`设置UNIT时间戳的过期时间

这些过期时间都存在了过期字典中(expire字典)，删除策略有三种：
- 定时删除：通过定时器保证键一旦过期就被删除
  - 优点：减少内存消耗
  - 缺点：删除过期键的这一行为会消耗CPU，浪费时间在与当前任务无关的过期键上，会对吞吐量造成影响。
- 惰性删除：只会在取出键时才会对键进行过期检查，保证了CPU时间，对内存不友好。可以看做是内存泄漏。
- 定期删除：定期删除每隔一段时间执行一次删除过期键的操作， 并且限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。Redis通过结合惰性和定期进行键删除。

## AOF、RDB和复制功能对过期键的处理
生成RDB文件时，不会保存过期的键，载入RDB文件时，主服务器不会载入过期的键，从服务器会载入所有键，但是在同步时会删除过期键所以不造成影响。

AOF文件在处理过期键时会在末尾追加`DEL`命令，重写时不会写入过期键。

## Redis基础知识


####  主从复制
Redis使用主从节点和哨兵模式结合解决单点故障的问题，提高Redis的可用性。从节点仅提供读操作，主节点提供写操作。对于读多写少的状况，可给主节点配置多少、个从节点，提高响应效率。

复制过程是这样的：
1. 从节点执行slaveof 保存主节点配置信息，使它变成主节点的从属服务器
2. 从节点中设置定时任务发现主节点信息，建立Socket连接
3. 从节点发送Ping信号接受Pong，明确两者能够互相通信(此Ping非彼Ping)
4. 连接建立后，主节点将所有数据发送给从节点（同步阶段）
5. 主节点把当前的数据同步给从节点后，变完成了复制的建立过程。接下来，主节点就会持续的将写命令发送给从节点

复制分为全量复制和部分复制，第一次建立连接会进行全量复制，offset字段维护各自的复制偏移量

全量复制过程：
1. 从节点发送psync后，主节点就知道其是第一次复制，返回FILLRESYNC runid offset，从节点保存
2. 生成RDB
3. 发送RDB，到从节点加载数据完成这段时间，主节点的写命令放入缓冲区
4. 从节点加载RDB文件

部分复制：
部分复制是再网络断开或者命令丢失等一场情况时，从节点想主节点请求补发丢失的命令数据，主节点的复制挤压缓冲区将这部分数据直接发给从节点。

重新发送时，会对照runid看看是否主节点是一致的。

---

#### 哨兵
主从复制存在的问题
- 一旦主节点宕机，从节点变为主，应用方需要修改主节点地址，其他的从节点需要去复制新的从节点
- 主节点的写入和存储受单机的限制

哨兵Sentinel的功能包括：主节点存活检测、主从运行情况检测、自动故障转移、主从切换。
- 不断检查主服务器和从服务器是否正常运行
- 出现问题可以及时通知
- 当主节点出现故障的时候，会将一个从节点升级为一个主节点，并且将其他的从节点指向新的主节点

工作原理：
- 每个Sentinel以秒为单位，向它知道的主从节点发送PING命令，如果一个节点的最后一次回复时间超过了一个值，会被标记为下线
- 如果主节点被标记了，那么正在监视这个节点的所有Sentinel都会去确认
- 当足够数量的Sentinel标记之后，主节点被标记为客观下线
- Sentinel会从info其他的从节点，并从中选出一个作为主节点，将其他从节点指向这个主节点



---

#### Redis为何这么快

1. 纯内存操作
2. 单线程操作，避免了频繁的上下文切换
3. 采用了非阻塞的IO多路复用机制

---

#### 数据类型

1. string，常规的get和set操作，可以为数值也可以为string。
2. hash，这里面的value放置的是结构化的对象。
3. set，存放不同的数据集合。
4. list，按照插入顺序放置的结构。

---

#### 持久化
AOF和RDB

RDB是一个时间点的全部的数据快照，是一个二进制的文件。一般会重新开启一个新的子进程进行RDB持久化，可以自动启动或者按时启动。写时复制（缺点：缺页中断可能很多）

1. Redis 使用操作系统的多进程 cow(Copy On Write) 机制来实现RDB快照持久化执行bgsave命令的时候，Redis主进程会检查是否有子进程在执行RDB/AOF持久化任务，如果有的话，直接返回
2. Redis主进程会fork一个子进程来执行执行RDB操作，fork操作会对主进程造成阻塞（影响Redis的读写），fork操作完成后会发消息给主进程，从而不再阻塞主进程。（阻塞仅指主进程fork子进程的过程，后续子进程执行操作时不会阻塞）
3. RDB子进程会根据Redis主进程的内存生成临时的快照文件，持久化完成后会使用临时快照文件替换掉原来的RDB文件。（该过程中主进程的读写不受影响，但Redis的写操作不会同步到主进程的主内存中，而是会写到一个临时的内存区域作为一个副本）
4. 子进程完成RDB持久化后会发消息给主进程，通知RDB持久化完成（将上阶段内存副本中的增量写数据同步到主内存）

优点：
- RDB文件小，非常适合定时备份，用于灾难恢复
- Redis加载RDB文件的速度比AOF快很多，因为RDB文件中直接存储的时内存数据，而AOF文件中存储的是一条条命令，需要重演命令。

缺点：
- RDB无法做到实时持久化，若在两次bgsave间宕机，则会丢失区间（分钟级）的增量数据，不适用于实时性要求较高的场景
- RDB的cow机制中，fork子进程属于重量级操作，并且会阻塞redis主进程
- 存在老版本的Redis不兼容新版本RDB格式文件的问题

---

AOF日志是持续增量的备份，是基于写命令存储的可读的文本文件。AOF日志会在持续运行中持续增大，由于Redis重启过程需要优先加载AOF日志进行指令重放以恢复数据，恢复时间会无比漫长。所以需要定期进行AOF重写，对AOF日志进行瘦身。目前AOF是Redis持久化的主流方式。

AOF是文件操作，对于变更操作比较密集的server，那么将造成磁盘IO的负荷加重。此外linux对文件操作采取了“延迟写入”手段，即并非每次write操作都会触发实际磁盘操作，而是进入了buffer中，当buffer数据达到阀值时触发实际写入(也有其他时机)，这是linux对文件系统的优化。可以设置成每条，每秒的策略，不必每次都进行写入。

#### AOF重写

AOF日志会在持续运行中持续增大，需要定期进行AOF重写，对AOF日志进行瘦身。

AOF Rewrite 虽然是“压缩”AOF文件的过程，但并非采用“基于原AOF文件”来重写或压缩，而是采取了类似RDB快照的方式：基于Copy On Write，全量遍历内存中数据，然后逐个序列到AOF文件中。因此AOF rewrite能够正确反应当前内存数据的状态。

AOF重写（bgrewriteaof）和RDB快照写入（bgsave）过程类似，二者都消耗磁盘IO。Redis采取了“schedule”策略：无论是“人工干预”还是系统触发，快照和重写需要逐个被执行。

重写过程中，对于新的变更操作将仍然被写入到原AOF文件中，同时这些新的变更操作也会被Redis收集起来。当内存中的数据被全部写入到新的AOF文件之后，收集的新的变更操作也将被一并追加到新的AOF文件中。然后将新AOF文件重命名为appendonly.aof，使用新AOF文件替换老文件，此后所有的操作都将被写入新的AOF文件。

优点：
- AOF只是追加写日志文件，对服务器性能影响较小，速度比RDB要快，消耗的内存较少

缺点：
- AOF方式生成的日志文件太大，需要不断AOF重写，进行瘦身。 
- 即使经过AOF重写瘦身，由于文件是文本文件，文件体积较大（相比于RDB的二进制文件）。  
- AOF重演命令式的恢复数据，速度显然比RDB要慢。

**在实际开发中，可以使用混合模式，对大粒度的数据使用RDB进行存储，而在RDB途中的数据可以使用AOF存储，这样在重启效率上就会很高**

---

#### 过期策略和淘汰策略

redis采用的是定期删除和惰性删除的策略：每隔一段的时间，随机抽取一段进行过期检查，过期就删除；惰性删除指的是当查询到的时候进行检查，过期则删除。

但是上诉策略还是存在一定的问题，当一个键值过期了却没有被访问，并且定期删除也没有访问到，其就会一直在内存中占用空间，所以基于此会诞生一些淘汰策略。

淘汰策略：也就是内存淘汰机制，分为以下几种
1. noeviction：内存不足时不插入。
2. allkeys-lru：移除最近最少使用的键值。
3. allkeys-random：随机移除。
4. volatile-lru：在内存不足的时候，从设置了过期时间的键中删除最近最少使用的。

---

#### 双写一致性问题
通过延迟双删除的方式保持一致性:[如何保障mysql和redis之间的数据一致性？](https://zhuanlan.zhihu.com/p/91770135)
1. 写数据时，先对缓存进行删除，再更新数据库，最后延时一段时间后再次删除缓存。
2. 读数据时，先检查缓存中有无数据，没有的话从数据库中进行查找，再更新到缓存。

需要评估自己的项目的读数据业务逻辑的耗时。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。

存在删除失败的情况，可以：
1. 通过设置过期时间尽量避免。
2. 使用中间件进行缓存写入。



---

#### 缓存穿透
请求在redis上没有，大量请求一瞬间涌向数据库中。
1. 通过布隆过滤器将那些不合法的请求直接在查找数据库之间拒绝。
2. 设置空值。

#### 缓存雪崩
大量的缓存在同一时间失效，请求都跑向数据库。
1. 给缓存的失效时间，加上一个随机值，避免集体失效。
2. 限流，在数据库负载达到一定时直接返回。


## 事件
Redis服务器是事件驱动，文件事件和时间事件。文件事件使用I/O多路复用来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的时间处理器。

文件事件处理器由套接字、I/O多路复用程序、文件事件分派器（dispatcher），以及事件处理器组成，文件事件是对套接字操作的抽象，每当一个套接字准备好执行连接应答、写入、读取、关闭等操作时，就会产生一个文件事件。因为一个服务器通常会连接多个套接字，所以多个事件可能会并发地出现。

<div align=center>
<img src="../img/文件事件.png">
</div>

I/O多路复用程序总是会将所有产生的事件的套接字都放到一个队列里面，然后通过这个队列，以有序、同步、每次一个套接字的方式向文件事件分派器传送套接字。当上一个套接字产生的事件被处理完毕之后，I/O多路复用程序才会继续向文件分派器传送下一个套接字。
<div align=center>
<img src="../img/分派器.png">
</div>

#### 时间事件
所有时间事件都放在一个无序链表汇中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器。当时间事件执行器运行时，必须遍历所有的时间事件，才能确保处理。


**因为时间事件的处理在文件事件后面，所以时间事件可能会有延迟**
serverCron：
- 更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况。
- 清理数据库中过期键值对。
- 关闭和清理连接失效的客户端。
- 尝试进行AOF和RDB持久化操作。
- 如果服务器是主服务器，那么对从服务器进行定期同步。
- 如果处于集群模式，对集群进行定期同步和连接测试。


---

## 内存管理函数

### zmalloc()
封装malloc进行内存分配，其中会进行内存对齐，zmalloc会给预定的size基础上多分配一个size_t的大小，用来存储size的值，这样可以精确地维护已经分配的内存大小。
update_zmalloc_stat_alloc函数（或者说zmalloc()相对malloc()而言）真正要实现的功能并不是进行8字节对齐（malloc已经保证了），它的真正目的是使变量used_memory精确的维护实际已分配内存的大小。

[zmalloc内存分配](https://blog.csdn.net/WhereIsHeroFrom/article/details/84578019)
