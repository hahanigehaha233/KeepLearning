### 互斥量 `Mutex`
Mutex是mutual exclusion的缩写，互斥量是用来确保同时仅有一个线程可以访问某项共享资源。更为全面的说法是，可以使用互斥量来保证对任意共享资源的原子访问。

任何时候，最多只有一个线程可以锁定该互斥量，试图对已经锁定的某一互斥量再次加锁，将可能阻塞线程或者报错失败，具体取决于加锁时使用的方法。

**只有所有者才能给互斥量解锁，这一属性改善了使用互斥量的代码结构**

使用函数`fcntl()`加锁、解锁一片文件区域和使用`System V 信号量 semaphore`，与互斥量相比在于，其锁定和解锁总是需要发起系统调用（system call），而每个系统调用的开销虽然小，但是很客观。互斥量的实现则是采用了机器语言级别的原子操作来完成。只有发生锁的争用时才会有系统调用，

**多个资源多个互斥量的话，规定互斥量的层级关系有预防死锁的效果**

### 条件变量 `Condition Variable`
互斥量防止多个线程同事访问同一共享变量。条件变量允许一个线程就某个共享变量（或其他共享资源）的状态变化通知其他线程，并让其他线程等待（阻塞）这一通知。

```
生产者                               消费者
lock(mutex)                         lock(mutex)
do somethings                       while(没有){wait(cond,mutex)}
i++                                 unlock(mutex)
unlock(mutex) 先解锁在通知效率更高，避免了
singal(cond)  可能出现的无谓线程切换（互斥代码段越少越好）


```

条件变量总是结合互斥量使用。条件变量就共享变量的状态改变发出通知，而互斥量则提供对该共享变量访问的互斥。
- 线程在准备检查共享变量状态时锁定互斥量。
- 检查共享变量的状态。
- 如果共享变量未处于预期状态，线程应在等待条件并进入休眠前解锁互斥量（以便其他线程能访问该共享变量）。
- 当线程因为条件变量的通知而被再度唤醒时，必须对互斥量再次加锁，因为在典型情况下，线程会立即访问共享变量。

**`wait()`中，对互斥量的释放和陷入对互斥量的等待属于同一个原子操作。**

重点，为什么是`while而不是if`：当代码返回时，并不能确定判断条件的状态，所以应该立即重新检查判断条件。
- 可能有多个线程在等待，其他线程可能率先醒来，进而改变判断条件的状态。
- 虚假唤醒（处理器进行的优化导致的）。
