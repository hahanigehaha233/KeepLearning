- 通信：这些工具关注的是进程之间的数据交换。
- 同步：关注进程和线程操作之间的同步。

通信工具包括
<div align=center>
<img src="../img/通信工具.png">
</div>
<div align=center>
<img src="../img/同步工具.png">
</div>

其中信号也可以算是一种同步工具。

在通信工具中，可以分为数据传输工具和共享内存两种通信方法。

#### 传输工具
传输工具要求在用户内存和内核内存之间进行两次数据传输：一次传输是在用户写入数据时从用户内存到内核内存，另一次传输是在读取的时候从内核到用户内存。数据传输工具可以进一步分为下列的类别：
- 字节流：通过管道、FIFO以及数据报socket交换的数据是一个无分隔符的字节流，每一个读取操作都可以从缓冲区中读取任意数量的字节，不管写入者写入的块大小是多少。
- 消息：通过消息队列，数据报socket交换的数据是以分隔符分隔的数据，每次的读取都会读取由写入者写入的一整条消息，无法只读取部分消息。
- 共享内存方式分为POSIX共享内存和内存映射。在使用共享内存时需要注意：
  - 虽然共享内存的通信速度很快，但是在共享内存上的操作是需要同步信号的，例如在一个进程试图读取一段内存时，而这段内存在被另一个进程写入。
  - 放入共享内存的数据对所有共享这块内存的进程可见。

#### 同步工具
同步工具的诞生是为了在多进程或线程的环境下，在对同一块内存进行操作时不出现预期之外情况，导致程序错误。有以下同步工具：
- 信号量：是由内核维护的一个整数，其值永远不会小于0。一个进程可以增加或减小一个信号量的值。如果一个进程试图将信号量减小到小于0，那么内核会阻塞该操作直至信号量的值增长到允许执行该操作的程度（或者返回错误）。一个进程减小信号量是为了预约对某些资源的独占访问，在完成了资源的使用之后可以增加信号量的值。
- 文件锁：文件锁是为了协调多个进程操作同一文件时的同步方法。文件锁分为读锁和写锁，任何进程都有持有文件的读锁，但是当一个进程持有文件写锁时，其他进程就无法再获取读锁和写锁了。（文件锁的操作其实可以使用互斥量+智能指针更加高效的完成）
- 互斥体和条件变量：多用于线程同步。

数据传输工具和共享内存方式存在几种差别：
- 传输工具的读取操作是有消耗性的，读取操作会消耗数据，其他进程无法获取已经读取了的数据。
- 读取者和写入者之间的同步是原子的。如果一个读取者试图从一个当前不包含数据的数据传输工具中读取数据，那么在默认情况下读取操作会被阻塞直至一些进程向该工具中写入。

---

## Socket
套接字分为网络套接字和Unix域套接字，域套接字只能用于单机的进程间信息交互，因为其没有使用网络协议栈，所以不会有添加删除报文、计算校验和等操作，它做的只是数据复制。在选择时可以按照以下几点进行。
- 网络套接字不仅可以运行在相同主机上，还可以运行在网络上的不同主机上，这是最为重要的一点。
- 在一些实现中，Unix域套接字是会比网络套接字要快的。
- 可以使用目录权限来控制Unix域套接字的访问。

---

## IPC
IPC是指Inter-Process Communication，进程间通信，POSIX IPC是指由`POSIX.1b`设计来取代与之类似的`System V IPC`机制的三种IPC机制--消息队列、信号量以及共享内存。


### `POSIX`消息队列

- 引用计数，只用所有当前使用队列的进程都关闭了队列之后才会对队列标记删除。
- 消息之间按照严格的优先级进行排列。
- 在一条消息可用时可用异步通知进程。具体为当一个为空的消息队列中有可读的消息时，会有可读的异步通知，这样就不用执行阻塞调用或者mq_receive()。
- POSIX是在内核2.6.6之后才加入的。

消息队列是使用描述符进行操作的，消息队列描述符和打开着的消息队列之间的关系与文件描述符和打开的文件之间的关系相似。如图：

<div align=center>
<img src="../img/消息队列描述符.png">
</div>

- 两个进程能够同时持有引用同一个打开的消息队列的消息队列描述符（图中的x），这在fork中会表现出来。
- 两个进程能够持有引用不同消息队列描述的打开的同一个消息队列的描述符。如图中的z和y。


```
打开消息队列
mq_open()函数创建一个新的消息队列或者打开一个既有队列。

关闭消息队列只是关闭进程操作的消息队列的描述符。
int mq_close(mqd_t mqdes);


真正删除一个消息队列，发生在所有进程使用完该消息队列后。
int mq_unlink(const char* name);

发送消息
int mq_send(mqd_t mqdes, const char* msg_ptr, size_t msg_len,
            unsigned int msg_prio);

接收消息会从消息队列中取出一个优先级最高、存在时间最长的消息进行删除。
如果消息队列为空，该操作会阻塞，如果设置为非阻塞的话会返回错误。
int mq_receive(mqd_t mqdes, char* msg_ptr, size_t msg_len,
              unsigned int *msg_prio);

通知消息
int mq_notify(mqd_t mqdes, const struct sigevent *notification)
```

跟System V消息对比，优势有：
- 允许在消息队列状态由空变为有时异步通知一个进程，但是存在诸多限制。
- 可以使用epoll等对其进行监控。

不足有：
- 可移植性稍差。
- 严格按照优先级进行排序，System V可以根据类型来选择消息的功能。

### `POSIX`信号量
