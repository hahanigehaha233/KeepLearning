## 基本数据类型
JAVA提供了八种数据类型，6中数值类型（4个整型，2个浮点型）、一种字符型，一种布尔型。
|类型|字节|
-|-
|byte|1|
|short|2|
|int|4|
|long|8|
|float|4|
|double|8|
|boolean|一位|
|char|2|

## JAVA常量
常量在运行时是不允许被修改的。

在JAVA中使用`final`关键字修饰常量，如：
```
final double PI = 3.14
```

## final 关键字
被final修饰的类不能被继承，既不能被重写，也不能拥有子类，final修饰的变量，无论是类属性、对象属性、形参还是局部变量，都需要进行初始化操作。

## volatile关键字
表示每次访问变量时都从主存中取得，而不是从线程的工作内存中取得。

## 自动类型转换
转换从低到高为
```
byte,short,char->int->long->float->double
```
- 不能对boolean类型进行转换
- 不能把对象类型转换成不相关类的对象
- 把容量大的类型转换成容量小的类型必须强制转换
- 可能溢出或者损失精度

## String类型为什么被final修饰
String类被`final`修饰，所以不能作为父类。
- 安全性：这设计到JVM的组成，JVM中拥有一块“本地方法栈”，其作用就是调用本地操作系统的API接口，而这些API是非常底层的，String类型中也使用到了。如果String开放继承，则开发人员通过继承之后重写方法便可以加入恶意代码。
- 方便性：设计成不可变时，有助于共享提高性能，可以将字符串对象存储在字符串常量池中。

所以在String类型中的方法，如substring、replace、toUpperCase等都是生成一个新的字符串。
```
因为使用了final关键字，JVM层面会直接优化成一个字符串字面量,在字节码中s3就已经是ab了
final String s1 = "a";
final String s2 = "b";
String s3 = s1 + s2;
String s4 = "ab";
System.out.println(s3 == s4) // true
```
[final 字符串比较](https://bbs.csdn.net/topics/392041804)

## StringBuffer和StringBuilder
- StringBuffer是线程安全和同步的，StringBuilder不是线程安全的。
- StringBuffer的性能是低于StringBuilder的。
- 两者内部都是维护了一个可变长度的char[]，所以是可以指定的，当append时长度不够，会重新创建一个char[]进行复制。
- （线程安全方面待完善）Synchronized
- String类型的“+”操作是使用了StringBuffer进行的。

## ArrayList 和 LinkedList（相当于数组和链表的区别）
### ArrayList
长度是动态的，但是只能存储对象，不能存储原生数据类型如int。
- 底层是基于动态数组，根据下标随机访问数组元素效率高，想数组尾部添加效率高；删除数组中元素效率低，在数组中间添加元素效率低。当数组容量不够扩容时会arraycopy().

### LinkedList
基于链表的动态数组，数组添加和删除效率非常高。
- 查找访问效率低，只能遍历。

## 类初始化顺序
```
父类静态变量 -> 父类静态初始块 -> 子类静态变量 -> 子类静态初始块 -> 父类成员变量 ->
父类非静态初始块 -> 父类构造器 -> 子类成员变量 -> 子类非静态初始块 -> 子类构造器
```

## Synchronized关键字 (实现原理待完善)
此关键字为同步关键字,在Java中，synchronized关键字是用来控制线程同步的，就是在多线程的环境下，控制synchronized代码段不被多个线程同时执行。
- synchronized 是不能被继承的，需要显式写出
- 修饰普通方法，此时锁的是当前实例对象,相当于`synchronized(this)`
```
public Synchronized void synMethod(){
  //do something
}
```
- 修饰静态方法，此时锁的是class对象,相当于`synchronized(this.class)`
```
public static synchronized void synMethod(){
  //do something
}
```

- 修饰同步代码块，此时锁的是括号里的对象,`synchronized(object)`
```
public void synMethod1(){
  synchronized (lock){
    //do something
  }
}
```
## HashMap 与 TreeMap 与 HashTable 与 ConcurrentHashMap
- Map是一个接口,是key-value键值对,一个map不能包含重复的key，并且每一个key只能映射一个value。
- Map接口提供了三个集合视图：key集合视图、value集合视图和key-value的集合。
- Map的具体实现中，HashMap允许存在null值，而HashTable的key值不允许为空，但是HashMap不能保证遍历元素的顺序，TreeMap能够保证遍历元素的顺序。
- HashMap（7和8的有不同）是数组+链表的实现结构(8中链表在超过阈值之后变成红黑树)，key值在加入时通过hash函数运算后得到散列值，再进行插入链表操作。
<div>
<img align="center" src="../img/hashmap.png">
</div>

- **HashMap属于多线程不安全类型，典型的场景就是在扩容时，因为没有保障，容易访问到已经弃用的地址。或者出现死循环的情况.**

- TreeMap是一个有序的key-value集合，通过红黑树实现，根据映射的自然顺序进行排序.不安全。因为要实现有序，key所属的类必须要实现Comparable接口,如果没有，则需要传入一个比较器。
<div align=center>
<img src="../img/treeMapUMI.jpg">
</div>

- Hashtable线程安全类，不允许null,因为每一个方法都使用了synchronized关键字，所以效率低下。

### ConcurrentHashMap
 ConcurrentHashMap采用分段锁实现，**适合写多读少** 从而实现了线程安全，简而言之，ConcurrentHashMap在对象中保存了一个Segment数组，即将整个Hash表划分为多个分段；而每个Segment元素，即每个分段则类似于一个Hashtable；这样，在执行put操作时首先根据hash算法定位到元素属于哪个Segment，然后对该Segment加锁即可。因此，ConcurrentHashMap在多线程并发编程中可是实现多线程put操作。
<div align=center>
<img src="../img/concurrentHashMap.png">
</div>

```
static final class HashEntry<K,V> {  
    final K key;  
    final int hash;  
    volatile V value;  
    final HashEntry<K,V> next;  
}
```

- (8)其节点中只有value不是`final`修饰的，这就说明在删除一个节点的时候，需要对整个链表(该节点前面的节点)进行操作，而且V是由`volatile`修饰，说明其可以一直获取到最新的值，在get操作时无需加锁。
- 扩容：扩容的时候首先会创建一个两倍于原容量的数组，然后将原数组里的元素进行再hash后插入到新的数组里。为了高效ConcurrentHashMap不会对整个容器进行扩容，而只对某个segment进行扩容。
- size（）：多次不加锁统计，有异常再进行加锁统计。

 [concurrentHashMap](https://blog.csdn.net/bill_xiang_/article/details/81122044)

 |名称|是否可以为空|默认大小|扩容方式|线程安全|
 -|-|-|-|-
 |hashtable|不可以|11|2*n+1|通过方法加锁保证|
 |hashMap|可以|16|2*n|不是线程安全|
 |TreeMap|不可以||不是线程安全|
 |concurrentHashMap1.7|不可以|默认16 | 申请一个原来大小两倍的空间，不需要重新hash，可以进行分段扩容|是线程安全|
 |concurrentHashMap1.8|不可以|默认16|当table数量小于64时，先进行扩容，如果大于，再转红黑树|线程安全|

JDK8的ConcurrentHashMap放弃了Segment加锁，使用了CAS+synchronized的方式来保证并发安全性。假设f为要被插入数据的节点，如果f为空的话，cas自旋插入，如果不为空的话对f加锁之后，对链表或红黑树进行操作。

 [JDK7/JDK8扩容方式](https://www.cnblogs.com/lfs2640666960/p/9621461.html)

 [JDK8 concurrentHashMap 操作](https://blog.csdn.net/jy02268879/article/details/88599830)

[concurrentHashMap transfer](https://www.cnblogs.com/menghuantiancheng/p/10462370.html)
