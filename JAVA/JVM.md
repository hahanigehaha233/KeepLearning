## 类加载的时机
类从被加载到虚拟机开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段。

加载阶段没有强制规定什么时候执行，但是在初始化阶段，虚拟机严格规定了5种情况必须立即进行初始化：
- 遇到`new、getstatic、putstatic、invokestatic`这四条字节码的时候，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令最常见的Java代码场景是：使用`new`关键字实例化对象的时候、读取或设置一个类的静态字段的时候，以及调用一个类的静态方法的时候。
- 使用`java.lang.reflect`包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
- 当初始化一个类的时候，发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
- 当虚拟机启动时，用户需要指定一个执行的主类（main（）所在的类），虚拟机会先初始化这个主类。
- 当使用JDK1.7的动态语言支持时，方法句柄对应的类没有进过初始化，则先触发初始化。

注意
- 对于静态字段，只有直接定义这个字段的类才会被初始化，所以通过子类引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。
```
父类中的value静态字段，子类中可以，这样引用下来只会实例化父类
subClass.value
```

- 通过数组定义的类引用，不会触发类的初始化,下面这个只是初始化了一个数组对象

```
SuperClass[] sca = new SuperClass[10];
```

- 一个类去引用另一个类的常量时，会在编译阶段做优化，会将常量存储到引用类中，所以也不会初始化被引用类。


## 类加载过程
类加载过程可以分为加载、验证、准备、解析和初始化5个阶段

### 加载
通常在加载阶段，虚拟机需要完成以下三件事情：
1. 通过一个类的全限定名来获取定义此类的二进制字节流。
2. 将这个二进制字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3. 在内存中生成一个代表这个类的`java.lang.Class`对象，作为方法区这个类的各种数据的访问入口。

对于非数组类，开发人员可以通过用户自定义的类加载器去完成字节流的获取。对于数组类，数组本身不通过类加载器创建，它是由Java虚拟机直接创建的。但是数组类和类加载器还是有很密切的关系，因为数组类的元素类型最终是要靠类加载器去创建，一个数组类的创建遵循以下规则：
- 如果数组类的组件类型是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组将在加载该组件类型的加载器的类名称空间上被标识。
- 如果数组的组件类型不是引用类型（例如`int[]`数组），Java虚拟机将会把数组标记为与引导类加载器关联。
- 数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组将默认为`public`。

加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义。并且在内存中生成一个Class类的对象。作为程序访问方法区中的这些类型数据的外部接口。


### 验证
验证一个Class的二进制内容是否合法，主要包含四个阶段：
- 文件格式验证：确保文件格式符合Class文件格式的规范.
- 元数据验证，确保Class的语义描述符合Java的Class规范。如：该Class是否有父类、是否错误继承了final类、是否一个合法的抽象类等。
- 字节码验证，通过分析数据流和控制流，确保程序语义符合逻辑。如：验证类型转换是合法的。
- 符号引用验证，发生于符号引用转换为直接引用的时候（转换发生在解析阶段）。如：验证引用的类、成员变量、方法的是否可以被访问（IllegalAccessError），当前类是否存在相应的方法、成员等（NoSuchMethodError、NoSuchFieldError）。


### 准备
准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在**方法区**中进行分配。这个阶段中有两个容易产生混淆的概念需要强调一下，首先，这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。第二，这里所说的初始值通常是指数据的零值.`final`例外。

### 解析
Java代码在进行Javac编译的时候，并不像C和C++那样有“连接”这一步，而是在虚拟机加载class文件之后进行动态连接。也就是说，在Class文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建或者是运行时解析、翻译到具体的内存地址中。

### 初始化
初始化阶段是执行类构造器`<clinit>()`方法的过程。其是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的。编译器收集的顺序是由源文件中出现的顺序决定的，**静态语句块中只能访问到定义在静态语句块之前的变量，定义在之后的变量，可以赋值，但是不能访问**。

- 如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成`<clinit>()`方法。
- 接口中可以有`<clinit>()`，并且父接口只有等到变量使用时才会初始化。
- 在这步虚拟机会阻塞多个初始化一个类的线程。


## 类加载器

### 双亲委派的好处
保证基础类仅加载一次，不会让JVM中存在重名的类。每次加载都委托给父加载器，最终都是BootstrapClassLoader，这样可以保证核心类都是其加载的，间接保证其安全性。

### 自定义类加载器
只需要继承`ClassLoader`类，然后覆盖`findClass(String name)`方面就可以完成一个带有双亲委派的类加载器。

findclass方法
```
protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        synchronized (getClassLoadingLock(name)) {
            // 查看是否已经加载过该类，加载过的类会有缓存，是使用native方法实现的
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                long t0 = System.nanoTime();
                try {
                    //父类不为空则先让父类加载
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                    //父类是null就是BootstrapClassLoader，使用启动类类加载器加载
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // 父类类加载器不能加载该类
                }

                //如果父类未加载该类
                if (c == null) {
                    // If still not found, then invoke findClass in order
                    // to find the class.
                    long t1 = System.nanoTime();
                    //让当前类加载器加载
                    c = findClass(name);
                }
            }
            return c;
        }
    }
```

`AppClassLoader 和 ExtClassLoader`都是Launcher中的静态加载类，所以不能继承自这两个类
