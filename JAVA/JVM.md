## 类加载的时机
类从被加载到虚拟机开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段。

加载阶段没有强制规定什么时候执行，但是在初始化阶段，虚拟机严格规定了5种情况必须立即进行初始化：
- 遇到`new、getstatic、putstatic、invokestatic`这四条字节码的时候，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令最常见的Java代码场景是：使用`new`关键字实例化对象的时候、读取或设置一个类的静态字段的时候，以及调用一个类的静态方法的时候。
- 使用`java.lang.reflect`包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
- 当初始化一个类的时候，发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
- 当虚拟机启动时，用户需要指定一个执行的主类（main（）所在的类），虚拟机会先初始化这个主类。
- 当使用JDK1.7的动态语言支持时，方法句柄对应的类没有进过初始化，则先触发初始化。

注意
- 对于静态字段，只有直接定义这个字段的类才会被初始化，所以通过子类引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。
```
父类中的value静态字段，子类中可以，这样引用下来只会实例化父类
subClass.value
```

- 通过数组定义的类引用，不会触发类的初始化,下面这个只是初始化了一个数组对象

```
SuperClass[] sca = new SuperClass[10];
```

- 一个类去引用另一个类的常量时，会在编译阶段做优化，会将常量存储到引用类中，所以也不会初始化被引用类。


## 类加载过程
类加载过程可以分为加载、验证、准备、解析和初始化5个阶段

### 加载
通常在加载阶段，虚拟机需要完成以下三件事情：
1. 通过一个类的全限定名来获取定义此类的二进制字节流。
2. 将这个二进制字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3. 在内存中生成一个代表这个类的`java.lang.Class`对象，作为方法区这个类的各种数据的访问入口。

对于非数组类，开发人员可以通过用户自定义的类加载器去完成字节流的获取。对于数组类，数组本身不通过类加载器创建，它是由Java虚拟机直接创建的。但是数组类和类加载器还是有很密切的关系，因为数组类的元素类型最终是要靠类加载器去创建，一个数组类的创建遵循以下规则：
- 如果数组类的组件类型是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组将在加载该组件类型的加载器的类名称空间上被标识。
- 如果数组的组件类型不是引用类型（例如`int[]`数组），Java虚拟机将会把数组标记为与引导类加载器关联。
- 数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组将默认为`public`。

加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义。并且在内存中生成一个Class类的对象。作为程序访问方法区中的这些类型数据的外部接口。


### 验证
验证一个Class的二进制内容是否合法，主要包含四个阶段：
- 文件格式验证：确保文件格式符合Class文件格式的规范.
- 元数据验证，确保Class的语义描述符合Java的Class规范。如：该Class是否有父类、是否错误继承了final类、是否一个合法的抽象类等。
- 字节码验证，通过分析数据流和控制流，确保程序语义符合逻辑。如：验证类型转换是合法的。
- 符号引用验证，发生于符号引用转换为直接引用的时候（转换发生在解析阶段）。如：验证引用的类、成员变量、方法的是否可以被访问（IllegalAccessError），当前类是否存在相应的方法、成员等（NoSuchMethodError、NoSuchFieldError）。


### 准备
准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在**方法区**中进行分配。这个阶段中有两个容易产生混淆的概念需要强调一下，首先，这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。第二，这里所说的初始值通常是指数据的零值.`final`例外。

### 解析
Java代码在进行Javac编译的时候，并不像C和C++那样有“连接”这一步，而是在虚拟机加载class文件之后进行动态连接。也就是说，在Class文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建或者是运行时解析、翻译到具体的内存地址中。

### 初始化
初始化阶段是执行类构造器`<clinit>()`方法的过程。其是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的。编译器收集的顺序是由源文件中出现的顺序决定的，**静态语句块中只能访问到定义在静态语句块之前的变量，定义在之后的变量，可以赋值，但是不能访问**。

- 如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成`<clinit>()`方法。
- 接口中可以有`<clinit>()`，并且父接口只有等到变量使用时才会初始化。
- 在这步虚拟机会阻塞多个初始化一个类的线程。


## 类加载器

### 双亲委派的好处
保证基础类仅加载一次，不会让JVM中存在重名的类。每次加载都委托给父加载器，最终都是BootstrapClassLoader，这样可以保证核心类都是其加载的，间接保证其安全性。

### 自定义类加载器
只需要继承`ClassLoader`类，然后覆盖`findClass(String name)`方面就可以完成一个带有双亲委派的类加载器。

findclass方法
```
protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        synchronized (getClassLoadingLock(name)) {
            // 查看是否已经加载过该类，加载过的类会有缓存，是使用native方法实现的
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                long t0 = System.nanoTime();
                try {
                    //父类不为空则先让父类加载
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                    //父类是null就是BootstrapClassLoader，使用启动类类加载器加载
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // 父类类加载器不能加载该类
                }

                //如果父类未加载该类
                if (c == null) {
                    // If still not found, then invoke findClass in order
                    // to find the class.
                    long t1 = System.nanoTime();
                    //让当前类加载器加载
                    c = findClass(name);
                }
            }
            return c;
        }
    }
```

`AppClassLoader 和 ExtClassLoader`都是Launcher中的静态加载类，所以不能继承自这两个类

## 先行发生原则
先行发生时Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。

在Java中有这些先行发生关系：
1. 程序次序规则：在一个线程内，按照程序代码的顺序，书写在前面的操作先行发生于书写在后面的操作。
2. 管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作，后面是指时间上的顺序。
3. volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作。
4. 线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作。
5. 线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，可以通过Thread.join()方法结束、Thread.interrupted()方法检测到是否已经终止执行。
6. 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程代码检测到中断时间的发生，可以通过Thread.interrupted()方法检测中断发生。
7. 对象终结规则：一个对象的初始化完成先于它的finalize()方法。
8. 传递性：如果操作A先行发生于操作B，操作B先行发生于操作C，那操作A就先行于操作C.

时间先后顺序与先行发生原则之间基本没有太大的关系，所以我们衡量并发安全问题的时候不要受到时间顺序的干扰，一切以先行发生原则为准。

## Java线程调度
线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，本别是协同式线程调度和抢占式线程调度。

Java中一共设置了10个级别的线程优先级（Thread.MIN_PRIORITY至Thread.MAX_PRIORITY）,在两个线程同时处于ready状态时，优先级越高的线程越容易被系统选择执行。我们不能简单地通过线程优先级来判断一组都为ready的线程哪个会先执行。

## Java线程状态
Java语言定义了5中线程状态，在任意一个时间点，一个线程只能有且只有其中一种状态，这5种状态分别是：
- 新建（New）：创建后尚未启动的线程处于这种状态。
- 运行（Runable）：Runable包括了操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着CPU为它分配执行时间。
- 无限期等待（Waiting）：处于这种状态的线程不会被分配CPU执行时间，它们要等待被其他线程显示地唤醒。以下方法会让线程陷入无限期的等待状态：
  - 没有设置timeout参数的Object.wait()方法
  - 没有设置timeout参数的Thread.join()方法
  - LockSupport.park()方法
- 限期等待（Timed Waiting）：处于这种状态的线程也不会被分配CPU执行时间，不过无须等待其被其他线程显式唤醒，在一定的时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态：
  - Thread.sleep()方法
  - 设置了Timeout参数的Object.wait()方法
  - 设置了Timeout参数的Thread.join()方法
  - LockSupport.parkNanos()方法
  - LockSuport.parkUntil()方法
- 阻塞（Blocked）：线程被阻塞了，“阻塞状态”和“等待状态”的区别是：“阻塞状态”在等待着获取到一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。
- 结束（Terminated）：已终止线程的线程状态，线程已经结束执行。

## 线程安全
定义：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。

我们把Java语言中的各种操作共享的数据分为以下5类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。
#### 不可变
不可变意味着不需要采取任何的线程安全保证措施，例如final关键字修饰的对象就可以保证不可变。“不可变”带来的安全性是最简单和最纯粹的。

**在Java API中，除了String类型是不可变的，常用的还有枚举类型，以及java.lang.Number的部分子类**

#### 绝对线程安全
这个程度的线程安全满足其定义，要达到这个“不管运行环境如何，调用者都不需要任何额外的同步措施”通常需要付出很大的代价。在Java API标注自己是线程安全的类，通常不是绝对的安全。例如Vector
```
while(true){
           for(int i=0;i<10;i++){
               vector.add(i); //往vector中添加元素
           }
           Thread removeThread=new Thread(new Runnable() {         
               @Override
               public void run() {
                   //获取vector的大小
                   for(int i=0;i<vector.size();i++){
                       //当前线程让出CPU,使例子中的错误更快出现
                       Thread.yield();
                       //移除第i个数据
                       vector.remove(i);
                   }
               }
           });
           Thread printThread=new Thread(new Runnable() {          
               @Override
               public void run() {
                   //获取vector的大小
                   for(int i=0;i<vector.size();i++){
                       //当前线程让出CPU,使例子中的错误更快出现
                       Thread.yield();
                       //获取第i个数据并打印
                       System.out.println(vector.get(i));
                   }
               }
           });         
           removeThread.start();
           printThread.start();
           //避免同时产生过多线程
           while(Thread.activeCount()>20);
       }

```
原因是Vector的线程安全是对get等方法使用锁进行的，无法在具体的业务逻辑中绝对安全。

#### 相对线程安全
保证这个对象单独操作起来是线程安全的。但是对于一些特定的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。

在Java语言中，大部分的线程安全类都属于这种类型，例如Vector、HashTable、Collections的sychronizedCollection()方法包装的集合等。

#### 线程兼容
是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象再并发环境中可以安全地使用，我们通常说一个类不是线程安全地，绝大多数的时候指的是这一种情况。Java API中大部分的类属于线程兼容，比如Vector和HashTable相对应的集合类ArrayList和HashMap

#### 线程对立
线程对立是无论如何使用同步措施，都无法在多线程环境中并发使用的代码。

## 线程安全的实现方法

#### 互斥同步
互斥同步是常见的一种并发正确性保障手段。同步是指在多个线程并发访问共享数据时，保证数据在同一个时刻只被一个线程使用。而互斥是实现同步的一种手段，临界区、互斥量、信号量都是主要的互斥实现方式。互斥是因，同步是果。

可以使用`synchronized`进行同步，`synchronized`同步块对于对象来说是可重入的，同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。但是Java的线程实现是映射到操作系统上的原生线程，在阻塞和唤醒时，就需要操作系统的核心态和用户态的切换，这种转换可能比用户代码执行的时间还要长。

也可以使用`ReentrantLock`实现同步。（待补充，在深入理解JVM的第十三章）

#### 非阻塞同步
通过乐观锁的同步，操作和冲突检测这两点都需要具备原子性，才能实现非阻塞同步，通过CPU的CAS指令，（总线锁）进行操作。

问题：
- ABA
- 时间：自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。
-  只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。
