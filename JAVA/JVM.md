## 虚拟机内存结构
根据Java SE7的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域：
#### 程序计数器（Program Counter Register）
程序计数器是一块较小的内存区域，它可以看做是当前线程所执行的字节码行号指示器。在虚拟机的概念模型里就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。

由于Java虚拟机的多线程是通过线程轮换分配处理器时间的方式来进行的。在任何一个时刻，一个处理器只会执行一条线程中的指令。因此，每个线程都有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。

如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

#### Java虚拟机栈（Java Virtual Machine Stacks）
这个区域也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口的信息。每一个方法从调用直到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

局部变量表中存放了编译期可知的各种基本数据类型、对象引用和returnAddress类型。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。

在Java虚拟机规范中，对着个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。

#### 本地方法栈（Native Method Stack）
本地方法栈与虚拟机栈锁发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务。在虚拟机规范中对本地方法栈中方法使用的语言、使用的方法与数据结构没有强制规定，本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常。

#### Java堆（Java Heap）
对于大多数应用来说，Java堆是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此区域的唯一目的就是存放对象实例，几乎所有对象实例以及数组都要在堆上分配，但是随着JIT编译期的发展和逃逸分析的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也不是绝对的了。

Java堆也是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”（Garbage Colected Heap），从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Surivor空间等。从内存分配的角度看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer TLAB）。无论怎么划分，都和存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。如果堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。

#### 方法区（Method Area）
和Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它有一个别名叫做Non-Heap（非堆），目的是与Java堆区分开来。有OutOfMemoryError异常。

#### 运行时常量池
Class文件中除了有类的版本、字段、方法、接口等描述信息往外，还有一项信息是常量池（Constant Pool Table），用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。这个池子是每一个类私有的。并不是一成不变的。在方法区中。
#### 字符串常量池
也是一种运行时的常量池，在运行的时候字符串常量会存储在这里，可以通过String.intern加入新的常量。（在堆中）

[字符串常量池](https://www.zhihu.com/question/22739143/answer/113822382)

#### 直接内存


 ##对象的创建
 虚拟机遇到一条new指令的时候，首先会去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用是否已经被加载、解析和初始化过。如果没有那必须先执行相应的类加载过程。

 在类加载检查通过之后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。

 内存分配完成后，虚拟机需要将分配的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

 接下来对对象进行必要的设置，例如这个对象是属于哪个实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中。根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

 接下来才会进行对象的<init>初始化

 对象三部分：对象头，实例数据，对齐填充
 ```
对象头的第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志
、线程持有的锁、偏向线程ID、偏向时间戳等，官方称这部分的数据为“Mark Word”。

另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个
对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针。

如果对象是一个Java数组，那对象头中还必须有一块用于记录数组长度的数据，因为虚
拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中无
法确定数组的大小。
 ```

#### 对象的访问定位

使用引用访问对象实例，目前主流的有使用句柄和直接指针两种。
- 如果使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。

- 如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。


## 类加载的时机
类从被加载到虚拟机开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段。

加载阶段没有强制规定什么时候执行，但是在初始化阶段，虚拟机严格规定了5种情况必须立即进行初始化：
- 遇到`new、getstatic、putstatic、invokestatic`这四条字节码的时候，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令最常见的Java代码场景是：使用`new`关键字实例化对象的时候、读取或设置一个类的静态字段的时候，以及调用一个类的静态方法的时候。
- 使用`java.lang.reflect`包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
- 当初始化一个类的时候，发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
- 当虚拟机启动时，用户需要指定一个执行的主类（main（）所在的类），虚拟机会先初始化这个主类。
- 当使用JDK1.7的动态语言支持时，方法句柄对应的类没有进过初始化，则先触发初始化。

注意
- 对于静态字段，只有直接定义这个字段的类才会被初始化，所以通过子类引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。
```
父类中的value静态字段，子类中可以，这样引用下来只会实例化父类
subClass.value
```

- 通过数组定义的类引用，不会触发类的初始化,下面这个只是初始化了一个数组对象

```
SuperClass[] sca = new SuperClass[10];
```

- 一个类去引用另一个类的常量时，会在编译阶段做优化，会将常量存储到引用类中，所以也不会初始化被引用类。


## 类加载过程
类加载过程可以分为加载、验证、准备、解析和初始化5个阶段

### 加载
通常在加载阶段，虚拟机需要完成以下三件事情：
1. 通过一个类的全限定名来获取定义此类的二进制字节流。
2. 将这个二进制字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3. 在内存中生成一个代表这个类的`java.lang.Class`对象，作为方法区这个类的各种数据的访问入口。

对于非数组类，开发人员可以通过用户自定义的类加载器去完成字节流的获取。对于数组类，数组本身不通过类加载器创建，它是由Java虚拟机直接创建的。但是数组类和类加载器还是有很密切的关系，因为数组类的元素类型最终是要靠类加载器去创建，一个数组类的创建遵循以下规则：
- 如果数组类的组件类型是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组将在加载该组件类型的加载器的类名称空间上被标识。
- 如果数组的组件类型不是引用类型（例如`int[]`数组），Java虚拟机将会把数组标记为与引导类加载器关联。
- 数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组将默认为`public`。

加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义。并且在内存中生成一个Class类的对象。作为程序访问方法区中的这些类型数据的外部接口。


### 验证
验证一个Class的二进制内容是否合法，主要包含四个阶段：
- 文件格式验证：确保文件格式符合Class文件格式的规范.
- 元数据验证，确保Class的语义描述符合Java的Class规范。如：该Class是否有父类、是否错误继承了final类、是否一个合法的抽象类等。
- 字节码验证，通过分析数据流和控制流，确保程序语义符合逻辑。如：验证类型转换是合法的。
- 符号引用验证，发生于符号引用转换为直接引用的时候（转换发生在解析阶段）。如：验证引用的类、成员变量、方法的是否可以被访问（IllegalAccessError），当前类是否存在相应的方法、成员等（NoSuchMethodError、NoSuchFieldError）。


### 准备
准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在**方法区**中进行分配。这个阶段中有两个容易产生混淆的概念需要强调一下，首先，这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。第二，这里所说的初始值通常是指数据的零值.`final`例外。

### 解析
Java代码在进行Javac编译的时候，并不像C和C++那样有“连接”这一步，而是在虚拟机加载class文件之后进行动态连接。也就是说，在Class文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建或者是运行时解析、翻译到具体的内存地址中。

### 初始化
初始化阶段是执行类构造器`<clinit>()`方法的过程。其是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的。编译器收集的顺序是由源文件中出现的顺序决定的，**静态语句块中只能访问到定义在静态语句块之前的变量，定义在之后的变量，可以赋值，但是不能访问**。

- 如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成`<clinit>()`方法。
- 接口中可以有`<clinit>()`，并且父接口只有等到变量使用时才会初始化。
- 在这步虚拟机会阻塞多个初始化一个类的线程。


## 类加载器

### 双亲委派的好处
保证基础类仅加载一次，不会让JVM中存在重名的类。每次加载都委托给父加载器，最终都是BootstrapClassLoader，这样可以保证核心类都是其加载的，间接保证其安全性。

### 自定义类加载器
只需要继承`ClassLoader`类，然后覆盖`findClass(String name)`方面就可以完成一个带有双亲委派的类加载器。

findclass方法
```
protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        synchronized (getClassLoadingLock(name)) {
            // 查看是否已经加载过该类，加载过的类会有缓存，是使用native方法实现的
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                long t0 = System.nanoTime();
                try {
                    //父类不为空则先让父类加载
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                    //父类是null就是BootstrapClassLoader，使用启动类类加载器加载
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // 父类类加载器不能加载该类
                }

                //如果父类未加载该类
                if (c == null) {
                    // If still not found, then invoke findClass in order
                    // to find the class.
                    long t1 = System.nanoTime();
                    //让当前类加载器加载
                    c = findClass(name);
                }
            }
            return c;
        }
    }
```

`AppClassLoader 和 ExtClassLoader`都是Launcher中的静态加载类，所以不能继承自这两个类

**java.lang.XXX自定义的类也是无法通过自定义加载器去加载的**

## 先行发生原则
先行发生时Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。

在Java中有这些先行发生关系：
1. 程序次序规则：在一个线程内，按照程序代码的顺序，书写在前面的操作先行发生于书写在后面的操作。
2. 管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作，后面是指时间上的顺序。
3. volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作。
4. 线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作。
5. 线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，可以通过Thread.join()方法结束、Thread.interrupted()方法检测到是否已经终止执行。
6. 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程代码检测到中断时间的发生，可以通过Thread.interrupted()方法检测中断发生。
7. 对象终结规则：一个对象的初始化完成先于它的finalize()方法。
8. 传递性：如果操作A先行发生于操作B，操作B先行发生于操作C，那操作A就先行于操作C.

时间先后顺序与先行发生原则之间基本没有太大的关系，所以我们衡量并发安全问题的时候不要受到时间顺序的干扰，一切以先行发生原则为准。

## Java线程调度
线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，本别是协同式线程调度和抢占式线程调度。

Java中一共设置了10个级别的线程优先级（Thread.MIN_PRIORITY至Thread.MAX_PRIORITY）,在两个线程同时处于ready状态时，优先级越高的线程越容易被系统选择执行。我们不能简单地通过线程优先级来判断一组都为ready的线程哪个会先执行。

## Java线程状态
Java语言定义了5中线程状态，在任意一个时间点，一个线程只能有且只有其中一种状态，这5种状态分别是：
- 新建（New）：创建后尚未启动的线程处于这种状态。
- 运行（Runable）：Runable包括了操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着CPU为它分配执行时间。
- 无限期等待（Waiting）：处于这种状态的线程不会被分配CPU执行时间，它们要等待被其他线程显示地唤醒。以下方法会让线程陷入无限期的等待状态：
  - 没有设置timeout参数的Object.wait()方法
  - 没有设置timeout参数的Thread.join()方法
  - LockSupport.park()方法
- 限期等待（Timed Waiting）：处于这种状态的线程也不会被分配CPU执行时间，不过无须等待其被其他线程显式唤醒，在一定的时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态：
  - Thread.sleep()方法
  - 设置了Timeout参数的Object.wait()方法
  - 设置了Timeout参数的Thread.join()方法
  - LockSupport.parkNanos()方法
  - LockSuport.parkUntil()方法
- 阻塞（Blocked）：线程被阻塞了，“阻塞状态”和“等待状态”的区别是：“阻塞状态”在等待着获取到一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。
- 结束（Terminated）：已终止线程的线程状态，线程已经结束执行。

## 线程安全
定义：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。

我们把Java语言中的各种操作共享的数据分为以下5类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。
#### 不可变
不可变意味着不需要采取任何的线程安全保证措施，例如final关键字修饰的对象就可以保证不可变。“不可变”带来的安全性是最简单和最纯粹的。

**在Java API中，除了String类型是不可变的，常用的还有枚举类型，以及java.lang.Number的部分子类**

#### 绝对线程安全
这个程度的线程安全满足其定义，要达到这个“不管运行环境如何，调用者都不需要任何额外的同步措施”通常需要付出很大的代价。在Java API标注自己是线程安全的类，通常不是绝对的安全。例如Vector
```
while(true){
           for(int i=0;i<10;i++){
               vector.add(i); //往vector中添加元素
           }
           Thread removeThread=new Thread(new Runnable() {         
               @Override
               public void run() {
                   //获取vector的大小
                   for(int i=0;i<vector.size();i++){
                       //当前线程让出CPU,使例子中的错误更快出现
                       Thread.yield();
                       //移除第i个数据
                       vector.remove(i);
                   }
               }
           });
           Thread printThread=new Thread(new Runnable() {          
               @Override
               public void run() {
                   //获取vector的大小
                   for(int i=0;i<vector.size();i++){
                       //当前线程让出CPU,使例子中的错误更快出现
                       Thread.yield();
                       //获取第i个数据并打印
                       System.out.println(vector.get(i));
                   }
               }
           });         
           removeThread.start();
           printThread.start();
           //避免同时产生过多线程
           while(Thread.activeCount()>20);
       }

```
原因是Vector的线程安全是对get等方法使用锁进行的，无法在具体的业务逻辑中绝对安全。

#### 相对线程安全
保证这个对象单独操作起来是线程安全的。但是对于一些特定的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。

在Java语言中，大部分的线程安全类都属于这种类型，例如Vector、HashTable、Collections的sychronizedCollection()方法包装的集合等。

#### 线程兼容
是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象再并发环境中可以安全地使用，我们通常说一个类不是线程安全地，绝大多数的时候指的是这一种情况。Java API中大部分的类属于线程兼容，比如Vector和HashTable相对应的集合类ArrayList和HashMap

#### 线程对立
线程对立是无论如何使用同步措施，都无法在多线程环境中并发使用的代码。

## 线程安全的实现方法

#### 互斥同步
互斥同步是常见的一种并发正确性保障手段。同步是指在多个线程并发访问共享数据时，保证数据在同一个时刻只被一个线程使用。而互斥是实现同步的一种手段，临界区、互斥量、信号量都是主要的互斥实现方式。互斥是因，同步是果。

可以使用`synchronized`进行同步，`synchronized`同步块对于对象来说是可重入的，同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。但是Java的线程实现是映射到操作系统上的原生线程，在阻塞和唤醒时，就需要操作系统的核心态和用户态的切换，这种转换可能比用户代码执行的时间还要长。

也可以使用`ReentrantLock`实现同步。（待补充，在深入理解JVM的第十三章）

#### 非阻塞同步
通过乐观锁的同步，操作和冲突检测这两点都需要具备原子性，才能实现非阻塞同步，通过CPU的CAS指令，（总线锁）进行操作。

问题：
- ABA
- 时间：自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。
-  只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。

[CAS介绍和相关问题](https://blog.csdn.net/liangwenmail/article/details/80832580)

## 锁优化
自旋锁与自适应锁

互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性能带来了很大的压力。共享数据的锁定只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。如果在物理机上有一个以上的处理器，能让两个或者以上的线程同时并行执行，就可以让后面请求锁的线程稍微等一下，使用忙循环来实现，这就是所谓的自旋锁。

#### 自旋锁
在1.4 引入自旋，自旋不能代替阻塞，虽然自旋本身避免了线程切换的开销，但它是要占用处理器时间的，因此，自旋的时间长短会影响自旋的性能。

#### 锁消除
是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。

#### 锁粗化
大部分情况下的细化是正确的，但是一系列的连续操作都对一个对象反复加锁和解锁，甚至加锁操作出现在循环体中，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。

#### 轻量级锁JDK1.6
轻量级锁使用在发生竞争很少的对象上

轻量级锁会在对象的头部申请一块空间：
1. 在代码进入同步块的时候，如果此同步对象没有被锁定，它的锁标志位是01，虚拟机会在当前线程的栈帧中建立一个名为所记录（Lock Record）的空间，用于存储对象目前的Mark Word拷贝。
2. 虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，如果这个更新动作成功了，那么这个线程就拥有看该对象的锁，并且对象Mark Word的锁标志位变为00，表示此对象处于轻量级锁定状态。
3. 如果这个更新操作失败了，虚拟机会检测对象的Mark Word是否指向当前线程的栈帧，如果是则说明当前线程已经拥有了这个对象的锁，直接进入同步块继续执行否则说明这个对象被其他线程抢占。
4. 解锁过程也是通过CAS操作进行。

#### 偏向锁JDK1.6
偏向锁的意思是，这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁可以被其他的线程获取，则持有偏向锁的线程将永远不需要同步。

### 详见锁分配过程.png
