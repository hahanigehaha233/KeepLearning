## <center>高性能缓存</center>
存储系统在计算要求高的时候往往会存在无法满足的情况，例如：
- 需要经过复杂运算后得到的数据，存储系统执行的话压力会很大。（计算count()）
- 读多写少的数据。典型的就是微博系统。

缓存的基本原理就是将可能重复使用到的数据放入内存中，一次生成，多次使用。内存访问的优势。

缓存系统会存在几个问题：

### 缓存穿透
缓存没有发挥到原本的作用，最后系统还是到存储系统中寻找数据。通常情况下有两种情况：
1. 存储数据不存在：查询一个不存在的数据，缓存中没有，进而到存储系统中寻找，在这个场景下没有起到分摊压力的作用。

2. 缓存数据生成耗费大量时间或资源。缓存失效后，还是会访问存储系统

具体的场景有：
- 分页缓存的有效期设置为 1 天，因为设置太长时间的话，缓存不能反应真实的数据。
- 通常情况下，用户不会从第 1 页到最后 1 页全部看完，一般用户访问集中在前 10 页，因此第 10 页以后的缓存过期失效的可能性很大。
- 竞争对手每周来爬取数据，爬虫会将所有分类的所有数据全部遍历，从第 1 页到最后 1 页全部都会读取，此时很多分页缓存可能都失效了。
- 由于很多分页都没有缓存数据，从数据库中生成缓存数据又非常耗费性能（order by limit 操作），因此爬虫会将整个数据库全部拖慢。

### 缓存雪崩
大量旧缓存失效之后，新的处理请求都会去重新生成缓存，在这一步会存在问题，可以采用**更新锁机制和后台更新机制**。

**更新锁机制**：对缓存更新机制进行加锁保护，保证只有一个线程能够进行缓存更新，未能获取更新锁的线程要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。

**后台更新机制**：由后台线程来更新缓存，而不是由业务线程来更新，缓存本身的有效期设置为永久，后台线程定时更新缓存。

在后台更新的这段时间，请求访问可能为空值，这是由于缓存过期之后，系统把缓存清理出内存，在后台进程加载之前，访问请求到达
