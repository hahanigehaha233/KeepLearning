# Reactor模式
主线程（IO处理单元）只负责监听文件描述符上是否有事件发生，有的话立刻将该事件通知工作线程（逻辑单元）。除此之外主线程不做任何其他工作，读写数据、接收新的连接及处理客户请求均在工作线程中完成。



使用Epoll实现的Reactor模式的工作流程如下：

1. 主线程往epoll内核事件表中注册socket上的读就绪事件。
2. 主线程调用epoll_wait等待socket上有数据可读。
3. 当socket上有数据可读时，epoll_wait通知主线程。主线程将socket可读事件放入请求队列。
4. 睡眠在请求队列上的工作线程被唤醒，它从socket读取数据，并处理客户请求。

上面是读事件的工作流程，写事件流程相同。



# Proactor模式

Proactor模式将所有IO操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。

使用异步IO模型（aio_read和aio_write）实现的Proactor模式的工作流程如下：

1. 主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序（回调函数）。
2. 主线程继续处理其他逻辑。
3. 当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知引用程序数据已经可用。
4. 应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求后，可用决定是否关闭socket。





# 使用同步IO模拟Proactor模式

主线程直接执行数据的读写操作，读写完成之后，主线程向工作队列通知这一“完成事件”。工作线程直接获取读写的结果并进行逻辑处理。





# 半同步半反应堆模式

​    通过使用epoll（IO多路复用）来监测IO操作，并把fd传给工作线程（Reactor模式），故称为半同步半反应堆模式。



半同步半反应堆模式是半同步半异步的变体，是将半异步变为具体的事件处理模型。可以是Proactor也可以是Reactor。





[介绍](https://www.jianshu.com/p/b132caf4f91b)



[区别](https://www.zhihu.com/question/26943938/answer/656823089)